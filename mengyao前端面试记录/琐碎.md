# 安全

**XSS（Cross-site scripting）**，指的是跨站脚本攻击，攻击者通过向页面 A 注入代码，达到窃取信息等目的，本质是数据被当作程序执行。XSS 危害是很大的，一般 XSS 可以做到以下的事情：

- 获取页面的数据，包括 dom、cookies、localStorage 等
- 劫持前端逻辑
- 发送请求

1.  XSS 的类型
    - 反射型（非持久）：通过 URL 参数直接注入
    - 存储型（持久）：存储到数据库后读取时注入
    - 基于 DOM：被执行的恶意脚本会修改页面脚本结构
2.  XSS 的注入点
    - HTML 的节点内容或属性
    - javascript 代码
    - 富文本
3.  防御措施（对用户输入内容和服务端返回内容进行过滤和转译）

- 现代大部分浏览器都自带 XSS 筛选器，vue / react 等成熟框架也对 XSS 进行一些防护
- 即便如此，我们在开发时也要注意和小心
- 对用户输入内容和服务端返回内容进行过滤和转译
- 重要内容加密传输
- 合理使用 get/post 等请求方式
- 对于 URL 携带参数谨慎使用
- 我们无法做到彻底阻止，但是能增加黑客攻击成本，当成本与利益不符时自然会降低风险

**CSRF(Cross Site Request Frogy)指的是跨站请求伪造**。与 XSS 不同的是，XSS 是攻击者直接对我们的网站 A 进行注入攻击，CSRF 是通过网站 B 对我们的网站 A 进行伪造请求。

举个例子，你登录购物网站 A 之后点击一个恶意链接 B，B 请求了网站 A 的下单接口，结果是你在网站 A 的帐号真的会生成一个订单。其背后的原理是：网站 B 通过表单、get 请求来伪造网站 A 的请求，这时候请求会带上网站 A 的 cookies，若登录态是保存在 cookies 中，则实现了伪造攻击。

防御措施（推荐添加 token / HTTP 头自定义属性）

- 涉及到数据修改操作严格使用 post 请求而不是 get 请求
- HTTP 协议中使用 Referer 属性来确定请求来源进行过滤（禁止外域）
- 请求地址添加 token ，使黑客无法伪造用户请求
- HTTP 头自定义属性验证（类似上一条）
- 显示验证方式：添加验证码、密码等

# 常用的 http 请求头

**1.Accept**

- **Accept: text/html**  浏览器可以接受服务器回发的类型为 text/html。
- **Accept: _/_**  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。
  **2.Accept-Encoding**
- **Accept-Encoding: gzip, deflate**  浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。
  **3.Accept-Language**
- **Accept-Language:zh-CN,zh;q=0.9**  浏览器申明自己接收的语言。
  **4.Connection**
- **Connection: keep-alive**  当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
- **Connection: close**  代表一个 Request 完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接会关闭， 当客户端再次发送 Request，需要重新建立 TCP 连接。

**5.Host（发送请求时，该报头域是必需的）**

- **Host：**  请求报头域主要用于指定被请求资源的 Internet 主机和端口号，它通常从 HTTP URL 中提取出来的。
  **6.Referer**
- **Referer:**  当浏览器向 web 服务器发送请求的时候，一般会带上 Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。

**7.User-Agent**

- **User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36**  告诉 HTTP 服务器， 客户端使用的操作系统和浏览器的名称和版本。
  **8.Cache-Control**
- **Cache-Control:private**  默认为 private 响应只能够作为私有的缓存，不能再用户间共享
- **`\*\*Cache-Control:public** `\*\*响应会被缓存，并且在多用户间共享。正常情况, 如果要求 HTTP 认证,响应会自动设置为 private.
- **Cache-Control:must-revalidate**  响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。
- **Cache-Control:no-cache**  响应不会被缓存,而是实时向服务器端请求资源。
- **Cache-Control:max-age=10**  设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。
- **Cache-Control:no-store**在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。
  **9.Cookie**
  Cookie 是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如 cookie 会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个 cookie 来存储相关信息，这样浏览器通过读取 cookie 的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然 cookie 里面的数据不仅仅是上述范围，还有很多信息可以存储是 cookie 里面，比如 sessionid 等。
  **10.Range（用于断点续传）**
- **Range:bytes=0-5**  指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。

# 常用的 http 响应头

**1.Cache-Control（对应请求中的 Cache-Control）**

- **Cache-Control:private**  默认为 private 响应只能够作为私有的缓存，不能再用户间共享
- **\_\_Cache-Control:public\*\***  浏览器和缓存服务器都可以缓存页面信息。
- **Cache-Control:must-revalidate**  对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。
- **Cache-Control:no-cache**  浏览器和缓存服务器都不应该缓存页面信息。
- **Cache-Control:max-age=10**  是通知浏览器 10 秒之内不要烦我，自己从缓冲区中刷新。
- **Cache-Control:no-store**  请求和响应的信息都不应该被存储在对方的磁盘系统中。

**2.Content-Type**

- **Content-Type：text/html;charset=UTF-8**  告诉客户端，资源文件的类型，还有字符编码，客户端通过 utf-8 对资源进行解码，然后对资源进行 html 解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。

**3.Content-Encoding**

- **Content-Encoding:gzip**  告诉客户端，服务端发送的资源是采用 gzip 编码的，客户端看到这个信息后，应该采用 gzip 对资源进行解码。
  **4.Date**
- **Date: Tue, 03 Apr 2018 03:52:28 GMT**  这个是服务端发送资源时的服务器时间，GMT 是格林尼治所在地的标准时间。http 协议中发送的时间都是 GMT 的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。
  **5.Server**
- **Server：Tengine/1.4.6**  这个是服务器和相对应的版本，只是告诉客户端服务器信息**。**
  **6.Transfer-Encoding**
- **Transfer-Encoding：chunked**  这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是 0 长度的，当客户端读到这个 0 长度的块时，就可以确定资源已经传输完了。
  **7.Expires**
- **Expires:Sun, 1 Jan 2000 01:00:00 GMT**  这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有 Cache-Control：max-age=\*这个响应头准确的，因为 max-age=date 中的 date 是个相对时间，不仅更好理解，也更准确。
  **8.Last-Modified**
- **Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT**  所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)
  **9.Connection**
- **Connection：keep-alive**  这个字段作为回应客户端的 Connection：keep-alive，告诉客户端服务器的 tcp 连接也是一个长连接，客户端可以继续使用这个 tcp 连接发送 http 请求。
  **10.Etag**
- **ETag: "737060cd8c284d8af7ad3082f209582d"**  就是一个对象（比如 URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会别修改，所以，ETag 的作用跟 Last-Modified 的作用差不多，主要供 WEB 服务器判断一个对象是否改变了。比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得 ETag 值发送给 WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。
  **11.Refresh**
- _\_Refresh: _\_  用于重定向，或者当一个新的资源被创建时。默认会在 5 秒后刷新重定向。
  **12.Access-Control-Allow-Origin**
- **Access-Control-Allow-Origin: \*** *号代表所有网站可以跨域资源共享，如果当前字段为*那么 Access-Control-Allow-Credentials 就不能为 true
- **Access-Control-Allow-Origin: [www.baidu.com](http://www.baidu.com/)**  指定哪些网站可以跨域资源共享
  **13.Access-Control-Allow-Methods**
- **Access-Control-Allow-Methods：GET,POST,PUT,DELETE**  允许哪些方法来访问
  **14.Access-Control-Allow-Credentials**
- **Access-Control-Allow-Credentials: true**  是否允许发送 cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。如果 access-control-allow-origin 为\*，当前字段就不能为 true
  **15.Content-Range**
- **Content-Range: bytes 0-5/7877**  指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。

# HTTPS

https://zhuanlan.zhihu.com/p/43789231
![[Pasted image 20220823232425.png]]

# HTTP1/2/3

看不懂

# ECharts

**ECharts**

ECharts 是百度开源的纯 Javascript 图表库，目前开源可以与 highcharts 相匹敌的一个图表库.支持折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K 线图、饼图（环形图）、雷达图（填充雷达图）、和弦图、力导向布局图、地图、仪表盘、漏斗图、事件河流图等 12 类图表，同时提供标题，详情气泡、图例、值域、数据区域、时间轴、工具箱等 7 个可交互组件，支持多图表、组件的联动和混搭展现。
**简单配置**

1.Head 内通过 script 引入 ECharts3 的 js：2.为 ECharts 准备一个具备大小（宽高）的 DOM :  
3.初始化 echarts 实例 var myChart = echarts.init(document.getElementById('main'));  
4.设置 Option 中参数，指定图表的配置项和数据  
5.使用 setoption 生成图表显示图表：myChart.setOption(option);

## SSO

单点登录方案 1.** 流程一：a 站点登录之后往 b 站点同步登录态**
以上是主动同步登录态的时序图。图示中的 ticket 主要存放在`redis`中，你也可以存放在其他的存储媒介甚至应用运行内存，但是需要注意的一点就是**ticket 应一次有效，用过之后需要清除掉**。由于这里我们的 b 站点也在自己的受控范围，并且 redis 的读写性能也相当优越，所以 a 和 b 连接并读取了同个 redis。如果 b 站点不在受控范围内，可在 b 站点后台发起一个请求到 a 站点询问 ticket 的有效状态。具体流程如下：

1.  用户访问[http://a.com](https://link.zhihu.com/?target=http%3A//a.com)的登录页；
2.  输入用户名密码登录，[http://a.com](https://link.zhihu.com/?target=http%3A//a.com)后台校验用户，成功之后生成 a 站点的 sesion 并生成一个 ticket 放入 redis 中；
3.  登录页面登录成功之后，拿到 ticket 往[http://b.com](https://link.zhihu.com/?target=http%3A//b.com)发送一个跨域请求（JSONP 或者 Image）；
4.  b 站点获取到 ticket 之后，检验在 redis 是否存在，存在着设置 b 站点 session 并删除 ticket；
5.  跨域请求返回之后继续其他操作，如跳转用户中心，首页等。 2.**流程二：b 站点无需登录页面主动同步 a 站点登录态**
6.  用户访问[http://b.com](https://link.zhihu.com/?target=http%3A//b.com)无需登录页面；
7.  如果当前站点用户未登录，发起异步 JSONP 请求到[http://a.com](https://link.zhihu.com/?target=http%3A//a.com)；
8.  如果[http://a.com](https://link.zhihu.com/?target=http%3A//a.com)未登录，不做任何操作。如果已经登录，跟上个流程一样，生成 ticket 信息；
9.  拿到 ticket 之后，请求 b 站点同步登录状态，b 站点生成 session；
10. 同步成功之后主动重新刷新当前页面。 3.**流程三： b 站点需登录页面主动跳转到 a 站点做登录态同步**
11. 用户访问[http://b.com](https://link.zhihu.com/?target=http%3A//b.com)需要登录页面，返回 302 跳转到 a 站点的状态同步页面；
12. a 站点状态同步页面判断站点登录状态，未登录状态跳转到 a 站点的登录页面，登录流程同流程一，登录成功之后跳转 b 站点需登录页面；
13. 已经登录状态做 JSONP 登录状态同步到 b 站点，b 站点生成 session；
14. 同步 b 站点成功之后跳转到[http://b.com](https://link.zhihu.com/?target=http%3A//b.com)站点需要登录页面。
    以上流程主要在于实现 SSO 过程的针对各种场景的解决方案，根据通过发起方的不同又可分为两类，主动同步和被动同步。主动同步是向认证站点获取 ticket 并同步自身登录态，被动同步是由认证站点向当前站点同步登录态。  
    一般网上的资料会有一个专门用作认证登录的站点，比如[http://a.com](https://link.zhihu.com/?target=http%3A//a.com)和[http://b.com](https://link.zhihu.com/?target=http%3A//b.com)站点都从[http://sso.a.com](https://link.zhihu.com/?target=http%3A//sso.a.com)获取认证状态。其实在本文中就是把 a 站点用作 sso 站点了，原理上是一致的。  
    为了这一套方案落地的时候，业务开发同事无需关注这部分实现细节并编写相应的同步代码，我们把他写入了整体框架里面，主要做了一下两件事：

15. 封装前端登录脚本（支持 npm 引用，直接 webpack 打包），登录之后去做主动站点同步，业务同事在需要登录的场景，直接调用方法并在回调函数做其他操作；
16. 使用 ejs 或者 pug 等模板引擎，将流程二的同步过程放入通用模板，其他页面在通用模板基础上创建。

更多关于 sso 认证方面的可以参考[OAuth2](https://link.zhihu.com/?target=https%3A//oauth.net/2/)的流程，这套流程用于不可信站点之间的认证在安全方面会更加成熟些，也是目前微信采用的认证流程。

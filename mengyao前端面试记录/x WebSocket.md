todo http http2 http3
## 是什么
一种在单个TCP连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。
在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。
WebSocket 的其他特点包括：
（1）建立在 TCP 协议之上，服务器端的实现比较容易。
（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
（3）数据格式比较轻量，性能开销小，通信高效。
（4）可以发送文本，也可以发送二进制数据。
（5）没有同源限制，客户端可以与任意服务器通信。
（6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。
### 为什么需要 WebSocket？
HTTP 协议有一个缺陷：
1.通信只能由客户端发起，不具备服务器推送能力
2.单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用["轮询"](https://link.juejin.cn/?target=https%3A%2F%2Fwww.pubnub.com%2Fblog%2F2014-12-01-http-long-polling%2F "https://www.pubnub.com/blog/2014-12-01-http-long-polling/")：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。
服务端被迫维持来自每个客户端的大量不同的连接
大量的轮询请求会造成高开销，比如会带上多余的header，造成了无用的数据传输。
### WebSocket 与 HTTP 的区别
**相同点：** 都是一样基于TCP的，都是可靠性传输协议。都是应用层协议。

**联系：** WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。
### 实现
用了 HTTP 协议来完成一部分握手
典型的 WebSocket 握手
```js
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```
多了这么几个东西。
```js
Upgrade: websocket
Connection: Upgrade
```
这个就是 WebSocket 的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的请求要用 WebSocket 协议，快点帮我找到对应的助理处理~而不是那个老土的 HTTP。

1.客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；
2.服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；
3.客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。
### 优缺点
**优点：**
1.W请求头是很小的
2.服务器可以向客户端推送消息了
**缺点：**
1.少部分浏览器不支持，浏览器支持的程度与方式有区别（IE10）
### 断线重连
断线原因：
1：websocket超时没有消息自动断开连接，应对措施：
需要知道服务端设置的超时时长是多少，在小于超时时间内发送心跳包，有两种方案:一种是客户端主动发送上行心跳包，另一种方案是服务端主动发送下行心跳包。
心跳检测步骤：
1.客户端每隔一个时间间隔发生一个探测包给服务器
2.客户端发包时启动一个超时定时器
3.服务器端接收到检测包，应该回应一个包
4.如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器
5.如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了

2：websocket异常包括服务端出现中断，交互切屏等等客户端异常中断等等
当若服务端宕机了，客户端怎么做、服务端再次上线时怎么做？
客户端则需要断开连接，通过onclose 关闭连接，服务端再次上线时则需要清除之间存的数据，若不清除 则会造成只要请求到服务端的都会被视为离线。
针对这种异常的中断解决方案就是处理重连
reconnecting-websocket.min.js，ws建立链接方法使用js库api方法
断网监测支持使用js库：offline.min.js

### 退化方案
1.ajax轮询
ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。
2.long poll
采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起请求后，如果没消息，就一直不返回 Response 给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。
缺点：
1.不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。服务端不能主动联系客户端，只能有客户端发起
2.消耗资源，ajax轮询 需要服务器有很快的处理速度和资源。long poll 需要有很高的并发
3.HTTP是一个无状态协议

### 三次握手
三次握手：作用就是`双方都能明确自己和对方的收、发能力是正常的`，确认序列号。
1.A->B SYN=1,seq=x B
2.B->A SYN=1,seq=y;ACK=1,ack=x+1
3.A->B ACK=1,ack=y+1
### 四次挥手
为了关闭双工，**半关闭**（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。
1.A->B Fin=1,seq=u
2.B->A ACK=1,ack=u+1,seq=v
一些B->A的数据发送
3.B->A FIN=1,seq=w,ACK=1,ack=u+1
4.A->B ACK=1,seq=u+1,ack=w+1

seq:我方（发送方）这边，这个packet的数据部分的第一位应该在整个data stream中所在的位置。
ack:期望的对方（接收方）的下一次sequence number是多少

等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 `CLOSED` 状态**（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端

### WSS?
可靠性 http://www.52im.net/thread-294-1-1.html
一致性与时序性 http://www.52im.net/thread-714-1-1.html
### IM的可靠性、一致性与时序性
#### 在线消息的可靠性
##### 确认机制
要想实现应用层的消息可靠投递，必须加入应用层的确认机制，即：要想让发送方client-A确保接收方client-B收到了消息，必须让接收方client-B给一个消息的确认，这个应用层的确认的流程，与消息的发送流程类似：  
-   client-B向im-server发送一个ack请求包，即ack:R
-   im-server在成功处理后，回复client-B一个ack响应包，即ack:A
-   则im-server主动向client-A发送一个ack通知包，即ack:N  
至此，发送“你好”的client-A，在收到了ack:N报文后，才能确认client-B真正接收到了“你好”。  
你会发现，一条消息的发送，分别包含（上）（下）两个半场，即msg的R/A/N三个报文，ack的R/A/N三个报文。一个应用层即时通讯消息的可靠投递，共涉及6个报文，这就是im系统中消息投递的最核心技术（如果某个im系统不包含这6个报文，不要谈什么消息的可靠性）。
##### 消息的超时与重传
client-A发出了msg:R，收到了msg:A之后，在一个期待的时间内，如果没有收到ack:N，client-A会尝试将msg:R重发。可能client-A同时发出了很多消息，故client-A需要在本地维护一个等待ack队列，并配合timer超时机制，来记录哪些消息没有收到ack:N，以定时重发。
一旦收到了ack:N，说明client-B收到了“你好”消息，对应的消息将从“等待ack队列”中移除。
##### 消息的重传存在什么问题
可能收到重复消息
解决：去重 uuid,由发送方client-A生成一个消息去重的msgid
##### 其他
1）上述设计理念，由客户端重传，可以保证服务端无状态性（架构设计基本准则）；  
2）如果client-B不在线，im-server保存了离线消息后，要伪造ack:N发送给client-A；  
3）离线消息的拉取，为了保证消息的可靠性，也需要有ack机制，但由于拉取离线消息不存在N报文，故实际情况要简单的多，即先发送offline:R报文拉取消息，收到offline:A后，再发送offlineack:R删除离线消息。
##### 总结
1）im系统是通过超时、重传、确认、去重的机制来保证消息的可靠投递，不丢不重；  
2）切记，一个“你好”的发送，包含上半场msg:R/A/N与下半场ack:R/A/N的6个报文。  
应用层的确认、发送方的超时重传、接收方的去重等手段来保证业务层面消息的不丢不重。
个人消息是一个1对1的ack，群消息就没有这么简单了，群消息存在一个扩散系数

### 时序性与一致性
1.以客户端或者服务端的时序为准
2.对于严格时序的业务场景，可以利用服务器的单调递增id来保证时序。
3.大部分业务能接受误差不大的趋势递增id
4.IM中单对单聊天，怎么保证发送顺序与接收顺序一致 发送方加一个递增id

1）分布式环境下，消息的有序性是很难的，原因多种多样：时钟不一致，多发送方，多接收方，多线程，网络传输不确定性等；  
2）要“有序”，先得有衡量“有序”的标尺，可以是客户端标尺，可以是服务端标尺；  
3）大部分业务能够接受大范围趋势有序，小范围误差；绝对有序的业务，可以借助服务器绝对时序的能力；  
4）单点序列化，是一种常见的保证多机时序统一的方法，典型场景有db主从一致，gfs多文件一致；  
5）单对单聊天，只需保证发出的时序与接收的时序一致，可以利用客户端seq；  
6）群聊，只需保证所有接收方消息时序一致，需要利用服务端seq，方法有两种，一种单点绝对时序，另一种id串行化。
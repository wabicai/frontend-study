## 本地存储
生命周期 local 浏览器关闭不会消失一直存在，除非主动清除缓存或者调用清楚接口 session 会话关闭  
范围 同域 协议域名端口 
大小： 5M
setitem getitem removeitem clear 
valuetostring转换成字符类型 用json.stringfy
读不存在的 读取出 null
![[Pasted image 20220612173940.png]]

# 1.1 cookie sessionStorage localStorage 区别
共同点：都是保存在浏览器端、且同源的

区别：

1.  cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
2.  存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大
3.  数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
4.  作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的
5.  web Storage支持事件通知机制，可以将数据更新的通知发送给监听者
6.  web Storage的api接口使用更方便
# 浏览器输入URL发生了什么
1.  URL 解析
2.  DNS 查询
3.  TCP 连接
4.  处理请求
5.  接受响应
6.  渲染页面


# 跨域是什么，如何解决跨域
同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

![](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646127140764/88627AFA1822F87A9F90B143461BEF84)

**同源策略限制内容有：**
-   Cookie、LocalStorage、IndexedDB 等存储性内容
-   DOM 节点
-   AJAX 请求发送后，结果被浏览器拦截了
但是有三个标签是允许跨域加载资源：
``` 
<img src='xxx'>  <link href='xxx'>  <script src='xxx'>
```
跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。
1.  跨域解决方案
    解决方案有jsonp、cors、postMessage、websocket、Node中间件代理(两次跨域)、nginx反向代理、window.name + iframe、location.hash + iframe、document.domain + iframe，CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案，JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。日常工作中，用得比较多的跨域方案是cors和nginx反向代理
CORS
    CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。
    浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。
    服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
2.nginx反向代理
**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略**
需要你搭建一个中转nginx服务器，用于转发请求。
使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。
实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。
# 安全
**XSS（Cross-site scripting）**，指的是跨站脚本攻击，攻击者通过向页面A注入代码，达到窃取信息等目的，本质是数据被当作程序执行。XSS危害是很大的，一般XSS可以做到以下的事情：

-   获取页面的数据，包括dom、cookies、localStorage等
-   劫持前端逻辑
-   发送请求
1.  XSS的类型
    -   反射型（非持久）：通过URL参数直接注入
    -   存储型（持久）：存储到数据库后读取时注入
    -   基于DOM：被执行的恶意脚本会修改页面脚本结构
2.  XSS的注入点
    -   HTML的节点内容或属性
    -   javascript代码
    -   富文本
3.  防御措施（对用户输入内容和服务端返回内容进行过滤和转译）
-   现代大部分浏览器都自带 XSS 筛选器，vue / react 等成熟框架也对 XSS 进行一些防护
-   即便如此，我们在开发时也要注意和小心
-   对用户输入内容和服务端返回内容进行过滤和转译
-   重要内容加密传输
-   合理使用get/post等请求方式
-   对于URL携带参数谨慎使用
-   我们无法做到彻底阻止，但是能增加黑客攻击成本，当成本与利益不符时自然会降低风险

**CSRF(Cross Site Request Frogy)指的是跨站请求伪造**。与XSS不同的是，XSS是攻击者直接对我们的网站A进行注入攻击，CSRF是通过网站B对我们的网站A进行伪造请求。

举个例子，你登录购物网站A之后点击一个恶意链接B，B请求了网站A的下单接口，结果是你在网站A的帐号真的会生成一个订单。其背后的原理是：网站B通过表单、get请求来伪造网站A的请求，这时候请求会带上网站A的cookies，若登录态是保存在cookies中，则实现了伪造攻击。

防御措施（推荐添加token / HTTP头自定义属性）
-   涉及到数据修改操作严格使用 post 请求而不是 get 请求
-   HTTP 协议中使用 Referer 属性来确定请求来源进行过滤（禁止外域）
-   请求地址添加 token ，使黑客无法伪造用户请求
-   HTTP 头自定义属性验证（类似上一条）
-   显示验证方式：添加验证码、密码等

# HTTP 状态码
-   1XX Informational（请求正在处理）
-   2XX Success（请求成功）
-   3XX Redirection（重定向） 需要进行附加操作以完成请求
-   4XX Client Error（客户端错误）
-   5XX Server Error（服务器错误）
-   200 OK 请求正常处理
-   204 请求处理成功 但是没有任何资源返回给客户端(一般用于只需客户端向服务端发送消息)
-   206 对资源的某一部分请求 响应报文中包含由 Content-Range 指定范围的实体内容
-   301永久重定向 如果把资源对应的URI保存为书签，则此时书签会根据Localtion首部字段提示的URI重新保存
-   302 临时重定向 临时地从旧地址A跳转到地址B
-   303 和301，302类似 当使用post方法访问一个资源时，把客户端以get的方式重定向到对应的URI，返回303状态码
-   304 资源已经找到，但是不满足条件，所以不把资源返回给客户端。常用于协商缓存。
-   400 请求报文内有语法错误
-   401 该状态码表示发送的请求需要通过HTTP认证，初次收到401响应浏览器弹出认证的对话窗口。若收到第二次401状态码，则说明第一次验证失败。
-   403 请求资源的访问被服务器拒绝，一般是未获得文件系统的访问权限，访问权限出现问题。
-   404 服务器上找不到请求资源 或路径错误
-   405 请求方法被服务端识别，但是服务端禁止使用该方法。可以用OPTIONS来查看服务器允许哪些访问方法
-   500 服务器端在执行请求时出错，一般是因为web应用出现bug
-   502 代理服务器或网关从上游服务器中收到无效响应
-   503 服务器暂时处于超负载或停机维护，目前无法处理请求
 
**1XX系列**：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。

**2XX系列**：代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201状态码。

**3XX系列**：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。这系列中最常见的有301、302状态码。

**4XX系列**：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。

**5xx系列**：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码。
**2开头 （请求成功）表示成功处理了请求的状态代码。**
-   200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
-   201 （已创建） 请求成功并且服务器创建了新的资源。
-   202 （已接受） 服务器已接受请求，但尚未处理。
-   203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。
-   204 （无内容） 服务器成功处理了请求，但没有返回任何内容。
-   205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。
-   206 （部分内容） 服务器成功处理了部分 GET 请求。
**3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。**
-   300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
-   301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
-   302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
-   303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
-   304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
-   305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
-   307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
**4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。**
-   400 （错误请求） 服务器不理解请求的语法。
-   401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
-   403 （禁止） 服务器拒绝请求。
-   404 （未找到） 服务器找不到请求的网页。
-   405 （方法禁用） 禁用请求中指定的方法。
-   406 （不接受） 无法使用请求的内容特性响应请求的网页。
-   407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
-   408 （请求超时） 服务器等候请求时发生超时。
-   409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
-   410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。
-   411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。
-   412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
-   413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
-   414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。
-   415 （不支持的媒体类型） 请求的格式不受请求页面的支持。
-   416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。
-   417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求。
**5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。**
-   500 （服务器内部错误） 服务器遇到错误，无法完成请求。
-   501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
-   502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
-   503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
-   504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
-   505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。


# DNS
DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。

DNS是应用层协议，事实上他是为其他应用层协议工作的，包括不限于HTTP和SMTP以及FTP，用于将用户提供的主机名解析为ip地址。  
具体过程如下：
1.  客户机提出域名解析请求 , 并将该请求发送给本地的域名服务器 ;
2.  当本地的域名服务器收到请求后 , 就先查询本地的缓存 , 如果有该纪录项 , 则本地的域名服务器就直接把查询的结果返回 ;
3.  如果本地的缓存中没有该纪录 , 则本地域名服务器就直接把请求发给根域名服务器 , 然后根域名服务器再返回给本地域名服务器一个所查询域 (根的子域) 的主域名服务器的地址 ;
4.  本地服务器再向上一步返回的域名服务器发送请求 , 然后接受请求的服务器查询自己的缓存 , 如果没有该纪录 , 则返回相关的下级的域名服务器的地址 ;
5.  重复第四步 , 直到找到正确的纪录 ;
6.  本地域名服务器把返回的结果保存到缓存 , 以备下一次使用 , 同时还将结果返回给客户机 ;
# OSI七层协议
**OSI**（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及，推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。  
**OSI定义了网络互连的七层框架**（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。

**1.应用层**
作用：它是与其他计算机进行通信的应用，它是对应应用程序的通信服务的。各种应用软件，包括web应用。
协议：DNS、FTP、HTTP、SMTP、TELNET、IRC、WHOIS
**2.表示层**
作用：这一层的主要作用是定义数据格式和加密。
**3.会话层**
作用：控制应用程序的会话能力，它定义了一段会话的开始、控制和结束，包括对多个双向消息的控制和管理，以便在只完成一部分消息时可以通知应用。
协议：
HTTP（Hyper text Transfer Protocol）协议：超文本传输协议使用TCP的80端口
FTP（File Transfer Protocol）文本传输协议
SMTP（Simple Mail Transfer Protocol）简单邮件传输协议，TCP是我25端口用户发邮件。
POP3（Post Office Protocol version3）邮局协议版本3，TCP的110号端口，用于收邮件的。
DNS（Domain Name System）域名解析协议。使用TCP和UDP的53号端口，作用是把www的域名解析成IP地址。
**4.传输层**
作用：对差错恢复协议和无差错恢复协议的选择，对同一主机上不同数据流的输入进行复用，对数据包进行重新排序。是最关键的一层，是唯一负责整体的数据传输和数据控制的。对上三层提供可靠的传输服务，对网络层提供可靠的目的地信息。在这一层数据的单位被称为数据段。
协议：TCP、UDP等
**5.网络层**
作用：主要负责寻找地址和路由选择，网络层还可以实现阻塞控制、网际互联等。
协议：IP、IPX、RIP、OSPF等
**6.数据链路层**
作用：负责物理层面上的互联的、节点间的通信传输；该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧（frame）
协议：ARP、RARP、SDLC、HDLC、PPP、STP、帧中继等
**7.物理层**
作用：负责0、1 比特流（0/1序列）与电压的高低、逛的闪灭之间的转换 规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性；该层为上层协议提供了一个传输数据的物理媒体。在这一层，数据的单位称为比特（bit）。
典型规范：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45、fddi令牌环网等
# tcp/ip协议栈、网络模型
TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。TCP/IP 协议采用4层结构，分别是**应用层、传输层、网络层和链路层**，
-   **链路层**：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；
-   **网络层**：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；
-   **传输层**：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；
-   **应用层**：定义数据格式，并按照对应的格式解读数据。
# CDN
Content Delivery Network，即内容分发网络。其目的是通过在现有的internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。CDN有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN=更智能的镜像+缓存+流量导流。因而，CDN可以明显提高Internet网络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。
# cdn加速原理
1.  当用户点击网站页面上的url时，经过本地dns系统解析，dns系统会将域名的解析权给交cname指向的cdn专用dns服务器。
2.  cdn的dns服务器将cdn的全局负载均衡设备ip地址返回给用户。
3.  用户向cdn的全局负载均衡设备发起内容url访问请求。
4.  cdn全局负载均衡设备根据用户ip，以及用户请求的内容url，选择一台用户所属区域的区域负载均衡设备
5.  区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址全局负载均衡设备把服务器的IP地址返回给用户。
6.  用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器 就要向它的上一级缓存服务器发起请求内容，直至追溯到网站的源服务器将内容拉回给用户。
# 常用的http请求头
**1.Accept**
-   **Accept: text/html** 浏览器可以接受服务器回发的类型为 text/html。
-   **Accept: */*** 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。
**2.Accept-Encoding**
-   **Accept-Encoding: gzip, deflate** 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。
**3.Accept-Language**
-   **Accept-Language:zh-CN,zh;q=0.9** 浏览器申明自己接收的语言。
**4.Connection**
-   **Connection: keep-alive** 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
-   **Connection: close** 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。

**5.Host（发送请求时，该报头域是必需的）**
-   **Host：** 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。
**6.Referer**
-   **Referer:** 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。

**7.User-Agent**
-   **User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36** 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。
**8.Cache-Control**
-   **Cache-Control:private** 默认为private 响应只能够作为私有的缓存，不能再用户间共享
-   **`\**Cache-Control:public** `**响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.
-   **Cache-Control:must-revalidate** 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。
-   **Cache-Control:no-cache** 响应不会被缓存,而是实时向服务器端请求资源。
-   **Cache-Control:max-age=10** 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。
-   **Cache-Control:no-store**在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。
**9.Cookie**
Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。
**10.Range（用于断点续传）**
-   **Range:bytes=0-5** 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。
# 常用的http响应头
**1.Cache-Control（对应请求中的Cache-Control）**
-   **Cache-Control:private** 默认为private 响应只能够作为私有的缓存，不能再用户间共享
-   **_\_Cache-Control:public**** 浏览器和缓存服务器都可以缓存页面信息。
-   **Cache-Control:must-revalidate** 对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。
-   **Cache-Control:no-cache** 浏览器和缓存服务器都不应该缓存页面信息。
-   **Cache-Control:max-age=10** 是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。
-   **Cache-Control:no-store** 请求和响应的信息都不应该被存储在对方的磁盘系统中。

**2.Content-Type**
-   **Content-Type：text/html;charset=UTF-8** 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。

**3.Content-Encoding**
-  **Content-Encoding:gzip** 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。
**4.Date**
-   **Date: Tue, 03 Apr 2018 03:52:28 GMT** 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。
**5.Server**
-   **Server：Tengine/1.4.6** 这个是服务器和相对应的版本，只是告诉客户端服务器信息**。**
**6.Transfer-Encoding**
-   **Transfer-Encoding：chunked** 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。
**7.Expires**
-   **Expires:Sun, 1 Jan 2000 01:00:00 GMT** 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。
**8.Last-Modified**
-   **Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT** 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)
**9.Connection**
-   **Connection：keep-alive** 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。
**10.Etag**
-  **ETag: "737060cd8c284d8af7ad3082f209582d"** 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。
**11.Refresh**
-   *_Refresh: *_ 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。
**12.Access-Control-Allow-Origin**
-   **Access-Control-Allow-Origin: *** _号代表所有网站可以跨域资源共享，如果当前字段为_那么Access-Control-Allow-Credentials就不能为true
-   **Access-Control-Allow-Origin: [www.baidu.com](http://www.baidu.com/)** 指定哪些网站可以跨域资源共享
**13.Access-Control-Allow-Methods**
-   **Access-Control-Allow-Methods：GET,POST,PUT,DELETE** 允许哪些方法来访问
**14.Access-Control-Allow-Credentials**
-   **Access-Control-Allow-Credentials: true** 是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true
**15.Content-Range**
-   **Content-Range: bytes 0-5/7877** 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。

# HTTPS
https://zhuanlan.zhihu.com/p/43789231
![[Pasted image 20220823232425.png]]
# HTTP1/2/3
看不懂

# ECharts
**ECharts**

ECharts是百度开源的纯 Javascript 图表库，目前开源可以与highcharts相匹敌的一个图表库.支持折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）、雷达图（填充雷达图）、和弦图、力导向布局图、地图、仪表盘、漏斗图、事件河流图等12类图表，同时提供标题，详情气泡、图例、值域、数据区域、时间轴、工具箱等7个可交互组件，支持多图表、组件的联动和混搭展现。
**简单配置**

1.Head内通过script引入ECharts3的js：2.为 ECharts 准备一个具备大小（宽高）的 DOM :  
3.初始化echarts实例var myChart = echarts.init(document.getElementById('main'));  
4.设置Option中参数，指定图表的配置项和数据  
5.使用setoption生成图表显示图表：myChart.setOption(option);

## SSO
单点登录方案
1.** 流程一：a站点登录之后往b站点同步登录态**
以上是主动同步登录态的时序图。图示中的ticket主要存放在`redis`中，你也可以存放在其他的存储媒介甚至应用运行内存，但是需要注意的一点就是**ticket应一次有效，用过之后需要清除掉**。由于这里我们的b站点也在自己的受控范围，并且redis的读写性能也相当优越，所以a和b连接并读取了同个redis。如果b站点不在受控范围内，可在b站点后台发起一个请求到a站点询问ticket的有效状态。具体流程如下：  

1.  用户访问[http://a.com](https://link.zhihu.com/?target=http%3A//a.com)的登录页；
2.  输入用户名密码登录，[http://a.com](https://link.zhihu.com/?target=http%3A//a.com)后台校验用户，成功之后生成a站点的sesion并生成一个ticket放入redis中；
3.  登录页面登录成功之后，拿到ticket往[http://b.com](https://link.zhihu.com/?target=http%3A//b.com)发送一个跨域请求（JSONP或者Image）；
4.  b站点获取到ticket之后，检验在redis是否存在，存在着设置b站点session并删除ticket；
5.  跨域请求返回之后继续其他操作，如跳转用户中心，首页等。
2.**流程二：b站点无需登录页面主动同步a站点登录态**
1.  用户访问[http://b.com](https://link.zhihu.com/?target=http%3A//b.com)无需登录页面；
2.  如果当前站点用户未登录，发起异步JSONP请求到[http://a.com](https://link.zhihu.com/?target=http%3A//a.com)；
3.  如果[http://a.com](https://link.zhihu.com/?target=http%3A//a.com)未登录，不做任何操作。如果已经登录，跟上个流程一样，生成ticket信息；
4.  拿到ticket之后，请求b站点同步登录状态，b站点生成session；
5.  同步成功之后主动重新刷新当前页面。
3.**流程三： b站点需登录页面主动跳转到a站点做登录态同步**
1.  用户访问[http://b.com](https://link.zhihu.com/?target=http%3A//b.com)需要登录页面，返回302跳转到a站点的状态同步页面；
2.  a站点状态同步页面判断站点登录状态，未登录状态跳转到a站点的登录页面，登录流程同流程一，登录成功之后跳转b站点需登录页面；
3.  已经登录状态做JSONP登录状态同步到b站点，b站点生成session；
4.  同步b站点成功之后跳转到[http://b.com](https://link.zhihu.com/?target=http%3A//b.com)站点需要登录页面。
以上流程主要在于实现SSO过程的针对各种场景的解决方案，根据通过发起方的不同又可分为两类，主动同步和被动同步。主动同步是向认证站点获取ticket并同步自身登录态，被动同步是由认证站点向当前站点同步登录态。  
一般网上的资料会有一个专门用作认证登录的站点，比如[http://a.com](https://link.zhihu.com/?target=http%3A//a.com)和[http://b.com](https://link.zhihu.com/?target=http%3A//b.com)站点都从[http://sso.a.com](https://link.zhihu.com/?target=http%3A//sso.a.com)获取认证状态。其实在本文中就是把a站点用作sso站点了，原理上是一致的。  
为了这一套方案落地的时候，业务开发同事无需关注这部分实现细节并编写相应的同步代码，我们把他写入了整体框架里面，主要做了一下两件事：  

1.  封装前端登录脚本（支持npm引用，直接webpack打包），登录之后去做主动站点同步，业务同事在需要登录的场景，直接调用方法并在回调函数做其他操作；
2.  使用ejs或者pug等模板引擎，将流程二的同步过程放入通用模板，其他页面在通用模板基础上创建。

更多关于sso认证方面的可以参考[OAuth2](https://link.zhihu.com/?target=https%3A//oauth.net/2/)的流程，这套流程用于不可信站点之间的认证在安全方面会更加成熟些，也是目前微信采用的认证流程。
# 结论
01. requestAnimationFrame和requestIdleCallback既不是宏任务也不是微任务
02. 浏览器每一帧中间可能会进行多轮事件循环, 所以每一轮Event Loop事件循环中不一定会去重新渲染屏幕
03. requestAnimationFrame执行在浏览器渲染前，在微任务执行后执行
04. requestIdleCallback是在浏览器渲染后有空闲时间时执行，如果requestIdleCallback设置了第二个参数timeout，则会在超时后的下一帧强制执行
# 浏览器任务执行顺序
01.  取出一个宏任务执行(一个script其实就是一个宏任务)
02.  JS引擎线程依次执行同步任务
03.  执行所有微任务
04.  判断是否更新渲染屏幕，如果需要重新绘制，则执行步骤5-14，如果不需要重新绘制，则流程回到步骤1
05.  触发resize、scroll事件，建立媒体查询(如果有新的微任务,则先把微任务队列清空)
06.  建立css动画(如果有新的微任务,则先把微任务队列清空)
07.  执行requestAnimationFrame回调(如果有新的微任务,则先把微任务队列清空)
08.  执行 IntersectionObserver 回调(如果有新的微任务,则先把微任务队列清空)
09.  更新渲染屏幕
10. 浏览器判断当前帧是否还有空闲时间，如果有空闲时间，则执行步骤11-13
11. 从 宏任务回调函数队列中取第一个，执行它
12. 执行微任务队列里的所有微任务
13. 流程回到步骤9，直到requestIdleCallback回调函数队列清空或当前帧没有空闲时间
14. 流程回到步骤1，这样不断循环

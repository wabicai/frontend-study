# 编译原理
JavaScript 是一门编译语言。与传统的编译语言不同的是，JavaScript 不是提前编译的，编译结果也不能在分布式系统中进行移植。

在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为 **编译**。
编译阶段分为三步：
1.分词 / 词法分析
2.解析 / 语法分析
3.代码生成

## 词法分析/分词
**词法分析**（Tokenizing / Lexing）这个过程会将由字符组成的字符串分解成有意义的代码块（对编程语言来说），这些代码块被称为 **词法单元**（Token）。
const a = 2;
这段程序通常会被分解成为下列词法单元：`var`、`a`、`=`、`2`、`;`
分词（Tokenizing）和词法分析（Lexing）之间的主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 `a` 是一个独立的词法单元还是其他词法单元的一部分时，调用的是 **有状态的解析规则**，那么这个过程就被称为 **词法分析**。
## 语法分析/解析
**语法分析**（Parsing） 这个过程是将词法单元流转换成一个 **由元素逐级嵌套所组成** 的代表了程序语法结构的树。这个树被称为 [抽象语法树](https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9)（Abstract Syntax Tree，AST 在各大框架及 [Babel](https://github.com/babel/babel) 中我们都会看到它的身影）。
## 代码生成
将 AST 转换为可执行代码的过程被称为 **代码生成**。这个过程与语言、目标平台等息息相关。 抛开具体细节，简单来说就是有某种方法可以将 `var a = 2;` 的 AST 转化为一组 **机器指令**：创建一个叫做 `a` 的变量（包括 **分配内存** 等），并将一个值存储在变量 `a` 中。

通过上述三个阶段，浏览器已经可以运行我们得到的 **可执行代码**，这三个阶段还有一个合称叫 **编译阶段**。我们把之后对可执行代码的执行称为 **运行阶段**。

# 编译过程
编译过程中的关键角色：
-**引擎**：从头到尾负责整个 JavaScript 程序的编译及执行过程
-**编译器**：负责语法分析及代码生成等步骤
-**作用域**：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限
### 编译过程详解
const a = 2;
通过以上论述可以得知，编译器首先会将这段代码分解成词法单元，然后将词法单元解构成一个树结构（AST），但是当编译器开始进行代码生成时，它对这段代码的处理方式会和预期的情况有所不同。
事实上编译器会进行如下操作：
1.  执行流遇到 `var a`，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为`a`。
2.  接下来编译器会为引擎生成运行所需的代码，这些代码被用来处理 `a = 2` 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中，是否存在一个叫作 `a` 的变量，如果是，引擎就会使用这个变量；如果否，引擎就会继续查找该变量。

总结起来就是：
-编译器在作用域声明变量（如果没有）
-引擎在运行这些代码时查找该变量，如果作用域中有该变量则进行赋值
    
在上面的第二步中，引擎执行运行时所需的代码时，会通过查找变量 `a` 来判断它是否已经声明过。查找的过程由作用域进行协助，但是引擎执行怎么查找，会影响最终的查找结果。

还是 `var a = 2;` 这个例子，引擎会为变量 `a` 进行 LHS 查询。当然还有一种 RHS 查询。

> 那么 LHS 和 RHS 查询是什么呢？

这里的 L 代表左侧，R 代表右侧。通俗且不严谨的解释 LHS 和 RHS 的含义就是：**当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。**

那么描述的更准确的一点，
**RHS** 查询与简单的查找某个变量的值毫无二致（**找值**）
**LHS** 查询则是试图找到变量的容器本身，从而可以对其赋值（**找容器**）。

需要注意的是：我们经常会将函数声明 `function foo(a) {...}` 转化为普通的变量赋值（函数表达式） `var foo = function(a) {…}`，这样去理解的话，这个函数是 LHS 查询。但是有一个细微的差别，编译器可以在代码生成的同时处理声明和值的定义，比如引擎执行代码时，并不会有线程专门用来将一个函数值"分配给" `foo`，因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。
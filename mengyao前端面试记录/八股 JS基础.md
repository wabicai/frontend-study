### 对原型、原型链的理解?
1.构造函数的内部都有一个 `prototype` 属性，属性值是一个对象，包含了可以该构造函数的所有实例共享的属性和方法
2.构造函数新**建一个对象**后，对象的内部将包含一个**指针**，指向构造函数的 prototype 属性值，这个指针被称为对象原型。一般来说不能直接获取，但是双下划线proto，Object.getPrototypeOf()方法获取。
3.当访问实例对象属性时，会现在对象内部找，找不到会顺着原型链找，直到到顶，`Object.prototype`的下一级是`Object.prototype.__proto__`为null为止。
在 JavaScript 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 `prototype` 属性，它的属性值是一个对象，这个对象包含了可以由**该构造函数的所有实例共享的属性和方法**。当使用构造函数新**建一个对象**后，在这个对象的内部将包含一个**指针**，这个指针**指向构造函数的 prototype 属性**对应的值，在 **ES5** 中这个指针被称为**对象的原型**。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 `proto` 属性来访问这个属性，但是最好不要使用这个属性，因为它**不是规范中规定**的。ES5 中新增了一个 `Object.getPrototypeOf()` 方法，可以通过这个方法来获取对象的原型。

当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是**原型链的概念**。**原型链的尽头**一般来说都是 `Object.prototype` 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。

**特点：** JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。

hasOwnProperty()：自己的属性
### 获取对象属性的方法
Object.keys values entries   `obj` 自身的可枚举字符串属性。
Object.getOwnPropertyNames(obj)  自身的所有字符串属性（包括不可枚举的），但不包括 Symbol 属性。
Object.getOwnPropertySymbols(obj)  `obj` 自身的所有 Symbol 属性（包括不可枚举的）**。
Reflect.ownKeys(obj)   `obj` 自身的所有属性集合** Symbol+字符串属性
for-in  **原型链上的所有可枚举字符串属性**
obj.hasOwnProperty('prop'); 自身是否包含该属性
### 闭包
**闭包是指有权访问另一个函数作用域中变量的函数**，创建闭包：在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。
**用途**；
1.闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
2.闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。
### 作用域、作用域链
全局作用域 函数作用域 块级作用域
**作用域链的本质上是一个指向变量对象的指针列表**。这样由多个执行上下文的 **变量对象** 构成的链表就叫做作用域链。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。
当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。
函数内部属性 `[[Scopes]]`，创建时，会保存父级作用域内的变量对象到其中。注意：`[[Scopes]]` 并不代表完整的作用域链。
当函数激活（执行）时，进入函数上下文，创建 VO / AO 后，就会将 **活动对象** 添加到作用域链的前端。 Scopes = [AO].concat([[Scopes]]); 当前+父级中的作用域链
### 变量对象
变量对象是与 [执行上下文](https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/execution/execution-context-stack) 相关的数据作用域，存储了在上下文中定义的 **变量** 和 **函数声明**。
### 执行上下文
全局执行上下文，函数，eval
JavaScript 引擎使用执行上下文栈来管理执行上下文
当 JavaScript 执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文
对于每一个执行上下文都含有三个重要属性：变量对象，作用域链，this
![[Pasted image 20220819174039.png]]
### 声明提升与变量提升
JS在编译阶段，函数声明和变量声明都会被先处理置于执行环境的顶部，且赋值会被留在原地，这个过程称之为提升。（函数提升的优先级最高，注意区别函数声明和函数表达式。）
### this
可以理解为当前的执行上下文；
显式绑定 > 构造调用绑定 > 隐式绑定 > 默认绑定 
箭头函数：实际原因是箭头函数根本没有自己的 `this`，导致内部的 `this` 就是外层代码块的 `this`。正是因为它没有 `this`，所以也就不能用作构造函数。
### let const var
var ES5 提升（undifined）方法作用域
let ES6 暂时性死区 （报错 is not defined） 块作用域
const ES6 声明时必须初始化 暂时性死区 变量内存的值不能改动
### 静态类型 动态类型 弱类型 强类型
静态类型、动态类型大家应该明白其实是指的Type Check发生的时机。静态类型指的是编译器在compile time执行类型检查，动态类型指的是编译器（虚拟机）在runtime执行类型检查。简单地说，在声明了一个变量之后，不能改变它的类型的语言，是静态语言；能够随时改变它的类型的语言，是动态语言。
弱/强类型指的是语言类型系统的类型检查的严格程度。弱类型相对于强类型来说类型检查更不严格，比如说允许变量类型的隐式转换，允许强制类型转换等等。强类型语言一般不允许这么做。
TS属于？
### 内存泄漏与避免
1.不合理使用的闭包
2.没请掉的定时器，
3.没销毁的时间监听
4.没清掉的DOM游离节点
5.没有成对使用的 addEventLisener removeEventLisner createurl revokeurl
### 判断变量类型
1.typeof  number sting boolen undifiend function  (null object->object)
2.instanceof 
3.Object.prototype.toString.call(a)
### 实现异步的方法
callback，settimeout,http请求
时间监听 发布订阅（都是回调吧，监听到添加后还是异步吗？）promise async await
### CSS样式的导入方式: link 和 @import
1.引入的内容不同
    link 除了引用样式文件，还可以引用图片等资源文件，而 @import 只引用样式文件
2.加载顺序不同
    link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载
3.兼容性不同
    link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持
4.对 JS 的支持不同
    link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持
### SRC 和 href
src用于替换当前元素，href用于在当前文档和引用资源之间确立联系
1.src
src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素,解析到该元素时，**会暂停其他资源的下载和处理**，直到将该资源加载、编译、执行完毕，图片和框架 等元素也如此，类似于将所指向资源嵌入当前标签内。**这也是为什么将js脚本放在底部而不是头部**
2.href
-href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接
在文档中添加link标签，浏览器会识别该文档为css文件，就会并行下载资源并且**不会**停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式
### ES6 模块与 CommonJS 模块有什么异同？
**ES6 Module 和 CommonJS 模块的区别：**
1.**拷贝，引用**：CommonJS模块输出的是一个值的**拷贝**，ES6 模块输出的是值的**引用**；
CommonJS一旦输出了某个值，如果模块内部后续的变化，影响不了外部对这个值的使用。es6等到脚本真正执行的时候，再根据这个只读引用，到被加载的那个模块里去取值。
2.**运行时加载，编译时输出接口依赖分析，编译优化**：CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
ES6模块不是对象，它的对外接口只是一种静态定义，在代码**静态解析阶段**就会生成，这样我们就可以使用各种工具对JS模块进行**依赖分析**，优化代码，而Webpack中的 `tree shaking` 和 `scope hoisting` 实际上就是依赖ES6模块化。
3.**this, 当前模块, undefined**
4.**互相引用**: 在ES6模块中可以直接加载CommonJS模块，但是只能整体加载，不能加载单一的输出项。
**ES6 Module 和 CommonJS 模块的共同点：**
### for...in 和 for...of
for...in key 遍历原型链  更适合遍历对象
for.. of valie iterator    不能遍历普通对象，要和object.keys()配合使用
### defer async
![[Pasted image 20220819162018.png]]
### 如何判断一个对象是否属于某个类？
1.第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
2.第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。
3.第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。
### for in vs for of
`for..of`迭代对象的键对应的值，value;关注于迭代对象的值,对象要有`Symbol.iterator`方法
`for..in`迭代的是对象的 _键_ 的列表，key; 可以操作任何对象,只遍历可枚举属性（包括它的原型链上的可枚举属性
**`Object.keys()`** 方法会返回一个由一个给定对象的自身可枚举属性组成的数组
### new 操作符的实现原理？
（1）首先创建了一个新的空对象
（2）设置原型，将对象的原型设置为函数的 prototype 对象。
（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是**引用类型**，就返回这个引用类型的对象。
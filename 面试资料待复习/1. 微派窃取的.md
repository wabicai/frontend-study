Css与布局方面
1. 你做过移动端项目，说说你们的移动端是如何进行适配的？
2. 说说rem，以及解决rem适配如果出现小数如何解决；
3. 是否做个横屏项目，说说横屏项目和竖屏项目在布局中差别
4. 现在设计给了一个竖屏全屏网页,背景图给的ipx的最长屏背景，产品希望不管长屏还是短屏手机，均能一屏展示，不要出现上下滚动的情况，请问如何布局？（限制100vh,100vw,hidden;背景图用bg-p: center；其他元素框在100vh100vw的absplute盒子内即可）；
5. Css伪元素使用是否多？什么场合使用？ 如果想让伪元素中的content动态变化，如何解决（attr(),attr不能解决什么动态类型）；
6. 遇到过什么奇怪的css问题或者比较难的css问题？ 遇到过fixed定位元素与子元素transform元素的冲突吗？

vue与组件方面
1. 封装过哪些组件，一个好的组件的封装有哪些注意事项，如何支持可扩展性？如果现在需要在一个旧的组件中做修改，如何避免引发重大副作用？
2. 在移动端中需要特别注意文字溢出的问题，现在要你封装一个支持单行多行溢出省略的组件，里面需要特别注意的是什么？大概写一下或者说说你的构思；（line-height）
3. （或者）移动端有大量的弹窗，需要有半透明蒙层，如果要你封装这个蒙层，你觉得必须提供哪些功能，如何更好支持扩展？弹窗一般采用fixed定位，但是这种情况就会限制了一些使用场景，说说哪些场景？
4. 你说了解Vue, 说说vue中组件间通信或者交互的方式有哪些，根据说出的几项说说其更适合的使用场景；（props, emit, provide/inject, $attrs/$events, $ref……）；
5. 现在有个项目首页，需要自动识别横屏竖屏，从而显示不同的页面样式；说说你的思路（提出conponent标签加分）
6. 我们现在项目使用了vue3， 你对vue3了解多少

Js方面
1. 你做过的项目中js编程的规范是哪些，你如何确保你写的代码能够清晰，规范，易读，尽可能抽离相关代码？
2. 在定义变量和方法时要注意哪些？
3. 遇到过js京精度问题吗？如何解决的； （最终封装成公用方法的加分）
4. 平时是否有考虑极值的情况，举例说明
5. 新手引导一般只对用户展示一遍，你觉得使用服务器存储还是前端缓存的好，为什么？
6. 

解决错误的能力
1. 测试告诉你交互，不符合预期，你排查的方式有哪些？
2. 遇到渲染白屏，你是如何定位问题解决问题的？
3. 遇到部分机型偶现bug，你如何解决（偶现必须找到必现方式）现在举例一个场景：偶有一两个人反馈，页面会出现卡死情况，如何快速定位解决？
4. 移动端方面的调试方式你用过哪些？
5. 我们知道，bug不可怕，可怕的是同样问题，反复出现； 在工作中你是如何提高这方面的能力的；以及如何降低bug率；

团队协作能力
1. 如何看待测试给你提的bug？
2. 服务器返回数据的数据，你要使用需要进行复杂处理，这时，你会让服务器帮忙还是自行处理，原则是什么？
3. 服务器有bug阻塞你接下来的开发，但是服务器一直在做其他的不屑于更改这个问题，你将怎么做？
4. 项目估时时你的原则是什么？如果估时不准怎么办？
5. 如果遇到自己能力之外的需求，你是怎么解决的？

扩展方面
1. 你平时有关注哪些技术相关网站，如何进行自我技术提升？
2. 你是如何看待工作和生活的关系的？


一、js相关
● 网页制作会用到的图片格式有哪些,介绍webp这个图片文件格式 
● 实现设计同学的UE效果动画，简单动画用代码即可实现，请问一些复杂动画，需要设计或者专门的动效师实现，你用过哪些？
● 从用户刷新网页开始，一次js 请求一般情况下有哪些地方会有缓存处理 （  dns缓存，cdn缓存，浏览器缓存，服务器缓存 ；参考）
● 个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？
● 浏览器内核的理解（渲染引擎，js引擎）
● 描述一下cookies,sessionStorage和localStorage的区别
● js的数据类型有哪些？以及说出判断js类型的方式
● 伪数组有哪些？有数组后为何要有伪数组；伪数组转数组的方式链接
● ES5和ES6分别集中方式声明变量；说说var和let，var和const的区别/ 或者说ES6为何要引入let和const？链接
● 闭包的概念，优缺点？ 说说对柯里化的了解（问防抖和截流）
● 赋值、浅拷贝和深拷贝； 写出对应方法； 你见到的浅拷贝的方式有哪些（assign, slice,concat, ...）；写出你用过的深拷贝浅拷贝和深拷贝
● HTTP常见状态码以及各自意思链接，HTTP重定向机制；HTTP请求头； 如何保证cookie安全链接
● Es  Module和CommonJs 有什么区别（说说JavaScript模块化(ES Module/CommonJs/AMD/CMD)的了解链接）
● 箭头函数有什么特点，考察一个this题目
● JS异步解决方案的发展历程以及优缺点
● HTTP常见状态码以及各自意思链接，HTTP重定向机制；HTTP请求头； 如何保证cookie安全链接
● 
●  13.module.exports与exports， export 和export default的区别链接
● 说说JavaScript模块化(ES Module/CommonJs/AMD/CMD)的了解链接
● 链接
● JS异步解决方案的发展历程以及优缺点
● 如何解决跨域问题
● 观察者和订阅-发布的区别，各自用在哪里
● prototype和——proto——区别
● _construct是什么
● new是怎么实现的
● base64为什么能提升性能，缺点
● var a = {name: "前端开发"}; var b = a; a = null
● 栈和堆的区别
● promise和setTimeout执行顺序的问题
```js
setTimeout(function(){console.log(1)},0);
new Promise(function(resolve){
    console.log(2)
    for( var i=0 ; i&lt;10000 ; i++ ){
        i==9999 &amp;&amp; resolve()
    }
    console.log(3)
}).then(function(){
    console.log(4)
});
console.log(5);
// 这的问题是，为什么答案是 2 3 5 4 1
// 而不是 2 3 5 1 4
// 既然promise.then和setTimeout都是异步的，那么在事件循环队列中 promise.then的事件应该排在setTimeout后面，那为什么promise.then却在setTimeout前面被打印了出来？
```
● JS为什么要区分微任务和宏任务链接
● Promise构造函数是同步还是异步执行，then呢
● 发布-订阅和观察者模式的区别

二、 HTTP相关
● HTTP常见状态码以及各自意思链接，HTTP重定向机制；HTTP请求头； 如何保证cookie安全链接
● 介绍http2.0
● Http报文的请求会有几个部分
● cookie
● cookie放哪里，cookie能做的事情和存在的价值
● cookie和token都存放在header里面，为什么只劫持前者
● cookie和session有哪些方面的区别
● tcs介绍
● tcp3次握手
● tcp属于哪一层（1 物理层 -> 2 数据链路层 -> 3 网络层(ip)-> 4 传输层(tcp) -> 5 应用层(http)）
● 缓存相关的HTTP请求头
● 403、301、302是什么
● HTTPS怎么建立安全通道
● a，b两个按钮，点击aba，返回顺序可能是baa，如何保证是aba（Promise.then）


三、CSS相关
● 移动端1px像素问题及解决办法；
● 介绍flex布局；
● CSS中为什么margin:auto只能实现水平居中不能实现垂直居中；链接
● 介绍css3中position:sticky
● 如何实现高度自适应
● 如下
● 
● 

四、webpack相关
1. webpakc呃介绍
1. 使用过webpack里面哪些plugin和loader
2. webpack里面的插件是怎么实现的
3. dev-server时如何跑起来的
4. 看


五、浏览器
1. 表单可以跨域吗？链接
六、ES6相关
● promise、async有什么区别
● 介绍暂时性死区
● ES6中let块作用域是怎么实现的

```js
// 将[1,2,3,4,5,6]分割成每项n个的二维数组
const chunk = (arr, size) => {
    let index = 0
    let newArr = []
    while(index < arr.length) {
      newArr.push(arr.slice(index,index += subLen))
    }
    return newArr
}

function Chunk(arr = [], size = 1) {
    return arr.length
    ? arr.reduce((t,v) => (t[t.length -1].length === size ? t.push([v]) : t[t.length -1].push(v),t) ,[[]])
    : []
}
```
```js
const arr1 = [1,2,3,4,5]
const arr2 = [1,3]
// 筛选出在arr2中没有的arr1的项
```
```js
// 在数组指定索引间的数据替换成指定值
const arr = [0, 1, 2, 3, 4, 5, 6];
function Fill(arr = [], val = "", start = 0, end = arr.length) {

}
Fill(arr, "aaa", 2, 5); // [0, 1, "aaa", "aaa", "aaa", 5, 6]

// 在数组指定索引间的数据替换成指定值
function Fill(arr = [], val = "", start = 0, end = arr.length) {
    if (start < 0 || start >= end || end > arr.length) return arr;
    return [
        ...arr.slice(0, start), // 截取0-start位置的值arr.slice(0, 2)不包含结尾的值即[0,1]
        // arr.slice(2, 5)即[2,3,4] [2,3,4].reduce((t,v) => (t.push(val)))
        ...arr.slice(start, end).reduce((t, v) => (t.push(val || v), t), []),
        // ...arr.slice(start, end),// 此处如果要选择插入
        ...arr.slice(end, arr.length)
    ];
}
```
```js
// 将[['a','b','c', 'd'], [1, true,'DR']] 转换成
// [['a', 1], ['b', true], ['c', 'DR'],['d']]
function Unzip(arr = []) {
    return arr.reduce(
        (t, v) => (v.forEach((w, i) => t[i].push(w)), t),
        Array.from({ length: Math.max(...arr.map(v => v.length)) }).map(v => [])
    );
}
```
```js

// 数组成员特性分组
const arr = [
    { area: "GZ", name: "YZW", age: 27 },
    { area: "GZ", name: "TYJ", age: 25 },
    { area: "SZ", name: "AAA", age: 23 },
    { area: "FS", name: "BBB", age: 21 },
    { area: "SZ", name: "CCC", age: 19 }
]; 
// 以地区area作为分组依据 { GZ: Array(2), SZ: Array(2), FS: Array(1) }

function Group(arr = [], key) {
    return key
    ? arr.reduce((t,v) => (!t[v[key]] && (t[v[key]] = []),t[v[key]].push(v),t),{})
    : {}
}
Group(arr, "area"); // { GZ: Array(2), SZ: Array(2), FS: Array(1) }
```
```js
// 数组转对象以name为依据，转成{"YZW": {...},'TYJ': {...}}
const people = [
    { area: "GZ", name: "YZW", age: 27 },
    { area: "SZ", name: "TYJ", age: 25 }
]
```
```js
const arr = [ 
  { id: 1, a: 1, b: 2 }, 
  { id: 1, a: 2, b: 2 }, 
  { id: 2, a: 1, b: 2 },
  { id: 3, a: 3, b: 2 }
]
// 将数组按照指定关键字去重

function Uniq(arr = [], key) {
    return arr.reduce((preRes,nextItem) => {
      return preRes.findIndex(item => item[key] === nextItem[key]) !== -1 ? preRes : [...preRes, nextItem]
    }, [])
}
```
```js
function myFlat(arr,num = 1) {
	return num > 0 
    ? arr.reduce((preRes, curItem)=> {
  			preRes.concat(Array.isArray(cutItem) ? myFlat(curItem, num -1): curItem)
 			}, [])
  	: arr.slice[]
}
```
## 1.小程序与普通网页开发的区别
https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8E%E6%99%AE%E9%80%9A%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB
​小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。
​**区别**
1.**渲染线程和脚本线程** :
网页中两个线程**互斥**的，长时间的脚本运行可能会导致页面失去响应，
小程序中，二者是分开，分别运行在不同的线程中。
**2.DOM API**：
网页开发者可以使用浏览器暴露出来的 DOM API，进行 DOM 选中和操作。
小程序逻辑层和渲染层是分开，逻辑层运行在 JSCore 中，没有一个完整浏览器对象，**缺少相关的DOM API和BOM AP**I。导致了一些库，例如 jQuery、 Zepto 等无法运行。
3.JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。
**4.运行环境的区别**
网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的，如表1-1所示。
![[Pasted image 20220820152813.png]]
**5.开发前置准备工作更多**
网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。
小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。
核心：双线程
https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html
小程序采用双线程架构，渲染线程（UI 线程）和逻辑线程（JS 线程）分离。`JS` 线程不会影响 `UI` 线程的动画表现，如滚动效果。但引入的问题是，`UI` 线程的事件发生后，需跨线程传递到 `JS` 线程，进而触发开发者回调，当做交互动画（如拖动元素）时，这种异步性会带来较大的延迟和不稳定。
AppService 和 WebView 的双线程模型，在 WebView 渲染之外新增了一个渲染引擎 Skyline，其使用更精简高效的渲染管线，并带来诸多增强特性，让 Skyline 拥有更接近原生渲染的性能体验。

## 2.小程序代码构成
1.`.json` 后缀的 `JSON` 配置文件
静态配置的角色
（1 `app.json` 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。
（2 工具配置 project.config.json
（3 页面配置  `同名.json` 
2.`.wxml` 后缀的 `WXML` 模板文件
和 `HTML` 非常相似，`WXML` 由标签、属性等等构成
差异：
（1 标签名字有点不一样
（2 多了一些 `wx:if` 这样的属性以及 {{ }} 这样的表达式
      MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 `JS` 直接操控 `DOM`，`JS` 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。
 特性：数据绑定，列表渲染，条件渲染，模版，引用
3`.wxss` 后缀的 `WXSS` 样式文件
（1 rpx 
  (2 提供了全局的样式和局部样式 app.wxss page.wxss
  (3 此外 `WXSS` 仅支持部分 `CSS` 选择器
4.`.js` 后缀的 `JS` 脚本逻辑文件
 事件响应
  bindtap="clickMe"
## 3.小程序宿主环境
微信客户端给小程序所提供的环境为宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。
### 渲染层和逻辑层
小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。

小程序的**渲染层**和**逻辑层**分别由2个线程管理：
**渲染层的界面使用了WebView** 进行渲染，一个小程序存在多个界面，所以渲染层存在多个 WebView 线程；
**逻辑层采用 JsCore** 线程运行 JS 脚本。
两个线程通信**经由微信客户端**（ Native ）做中转，逻辑层发送网络请求也经由 Native 转发，小程序的通信模型下图所示。
![[Pasted image 20220820155947.png]]
#### 响应的数据绑定
框架核心：响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。
1.开发者通过框架将逻辑层数据中的 `name` 与视图层的 `name` 进行了绑定，所以在页面一打开的时候会显示 `Hello Weixin!`；
2.当点击按钮的时候，视图层会发送 `changeName` 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数；
3.回调函数触发后，逻辑层执行 `setData` 的操作，将 `data` 中的 `name` 从 `Weixin` 变为 `MINA`，因为该数据和视图层已经绑定了，从而视图层会自动改变为 `Hello MINA!`。

### 程序与页面
### 逻辑层 App Service
小程序开发框架的逻辑层使用 `JavaScript` 引擎为小程序提供开发者 `JavaScript` 代码的运行环境以及微信小程序的特有功能。
逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。
开发者写的所有代码最终将会打包成一份 `JavaScript` 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 [ServiceWorker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)，所以逻辑层也称之为 App Service。
在 `JavaScript` 的基础上，我们增加了一些功能，以方便小程序的开发：
1.增加 `App` 和 `Page` 方法，进行[程序注册](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html)和[页面注册](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html)。
2.增加 `getApp` 和 `getCurrentPages` 方法，分别用来获取 `App` 实例和当前页面栈。
3.提供丰富的 [API](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html)，如微信用户数据，扫一扫，支付等微信特有能力。
4.提供[模块化](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%A8%A1%E5%9D%97%E5%8C%96)能力，每个页面有独立的[作用域](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F)。

**注意：小程序框架的逻辑层并非运行在浏览器中，因此 `JavaScript` 在 web 中一些能力都无法使用，如 `window`，`document` 等。**
#### 1.注册小程序
每个小程序都需要在 `app.js` 中调用 `App` 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。
详细的参数含义和使用请参考 [App 参考文档](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html) 。

```
// app.js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})
```

整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 `getApp` 方法获取到全局唯一的 App 实例，获取 App 上的数据或调用开发者注册在 `App` 上的函数。

```
// xxx.js
const appInstance = getApp()
console.log(appInstance.globalData) // I am global data
```
#### 2.注册页面
对于小程序中的每个页面，都需要在页面对应的 `js` 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。
简单的页面可以使用 `Page()` 进行构造。
**代码示例：**

```
//index.js
Page({
  data: {
    text: "This is page data."
  },
  onLoad: function(options) {
    // 页面创建时执行
  },
  onShow: function() {
    // 页面出现在前台时执行
  },
  onReady: function() {
    // 页面首次渲染完毕时执行
  },
  onHide: function() {
    // 页面从前台变为后台时执行
  },
  onUnload: function() {
    // 页面销毁时执行
  },
  onPullDownRefresh: function() {
    // 触发下拉刷新时执行
  },
  onReachBottom: function() {
    // 页面触底时执行
  },
  onShareAppMessage: function () {
    // 页面被用户分享时执行
  },
  onPageScroll: function() {
    // 页面滚动时执行
  },
  onResize: function() {
    // 页面尺寸变化时执行
  },
  onTabItemTap(item) {
    // tab 点击时执行
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)
  },
  // 事件响应函数
  viewTap: function() {
    this.setData({
      text: 'Set some data for updating view.'
    }, function() {
      // this is setData callback
    })
  },
  // 自由数据
  customData: {
    hi: 'MINA'
  }
})
```
#### 页面中使用 behaviors
behaviors 可以用来让多个页面有相同的数据字段和方法。
### 视图层 View
框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。
将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。
WXML(WeiXin Markup language) 用于描述页面的结构。
WXS(WeiXin Script) 是小程序的一套脚本语言，结合 `WXML`，可以构建出页面的结构。
WXSS(WeiXin Style Sheet) 用于描述页面的样式。
组件(Component)是视图的基本组成单元

## 性能与体验
#### 启动性能优化
启动性能优化最直接的手段是**降低代码包大小**，代码包大小直接影响了下载耗时，影响用户启动小程序时的体验。

开发者可以采取以下手段优化代码包体积
1.合理使用分包加载
独立分包，分包预加载
2.避免非必要的全局自定义组件和插件
3.控制代码包内的资源文件
代码包在下载时会使用 ZSTD 算法进行压缩，图片、音频、视频、字体等资源文件会占用较多代码包体积，并且通常难以进一步被压缩，对于下载耗时的影响比代码文件大得多。
建议开发者在代码包内的图片一般应只包含一些体积较小的图标，避免在代码包中包含或在 WXSS 中使用 base64 内联过多、过大的图片等资源文件。这类文件应尽可能部署到 CDN，并使用 URL 引入。
4.及时清理无用代码和资源
意外引入的第三方库、版本迭代中被废弃的代码或依赖、产品环境不需要的测试代码、**未使用的组件、插件、扩展库**，这些没有被实际使用到的文件和资源也会被打入到代码包里，从而影响到代码包的大小。
「[代码静态依赖分析](https://developers.weixin.qq.com/miniprogram/dev/devtools/codeanalyse.html)」，不定期地分析代码包的文件构成和依赖关系，以此优化代码包大小和内容。对于仅用于本地开发调试，不应包含在小程序代码包的文件，可以使用工具设置的 [packOptions.ignore](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html) 配置忽略规则。
在使用打包工具（如 Webpack、Rollup 等）对小程序代码进行预处理时，可以利用 tree-shaking 等特性去除冗余代码，也要注意防止打包时引入不需要的库和依赖。

#### 首屏渲染优化
页面首屏渲染的优化，目的是让「首页渲染完成」(`Page.onReady`) 尽可能提前。但很多情况下「首页渲染完成」可能还是空白页面，因此更重要的是让用户能够更早的看到页面内容（First Paint 或 First Contentful Paint）
1.使用「[按需注入](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/lazyload.html#%E6%8C%89%E9%9C%80%E6%B3%A8%E5%85%A5)」和「[用时注入](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/lazyload.html#%E7%94%A8%E6%97%B6%E6%B3%A8%E5%85%A5)」
2.启用「[初始渲染缓存](https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html)」
3.避免引用未使用的自定义组件
4.精简首屏数据
5.提前首屏数据请求
6.缓存请求数据
7.骨架屏

# 简述微信小程序的原理
-   微信小程序采用JavaScript、WXML、WXSS三种技术进行开发,本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口
-   微信的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现
-   小程序分为两个部分webview和appService。其中webview主要用来展现UI ，appService有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层JSBridge实现通信，实现 UI 的渲染、事件的处理
# 发送一个请求，怎么请求数据的
1.  在微信小程序进行网络通信，只能和指定的域名进行通信  
    服务器域名在：小程序后台=> 开发=> 开发设置 => 服务器域名中配置，配置时需注意：
    1）域名只支持https（request, uploadFile，downloadFile）和wss（connectSocket）协议。
    2）域名不能使用ip地址或localhost。
    3）域名必须经过ICP备案。
    4）服务器域名一个月内可申请5次修改。
2.  微信小程序包括四种类型的网络请求
    1) 普通HTTPS请求(wx.request)
    2) 上传文件(wx.uploadFile)
    3) 下载文件(wx.downloadFile)
    4) WebSocket通信(wx.connectSocket)
3.  小程序没有跨域的限制：
    在普通网站中，由于浏览器的同源策略限制，存在数据的跨域请求问题，从而衍生出JSONP和CORS 两种主流的跨域问题解决方案，但是小程序内部运行机制与网页不同，小程序中的代码并不运行在浏览器中，因此小程序开发中，不存在数据的跨域请求限制问题。

# 数据怎么同步渲染setData方法
小程序分为逻辑层和渲染层，而我们每次逻辑层改变了，要借由 Native 进行。小程序的渲染层和逻辑层由两个线程管理：渲染层的界面使用了 WebView 进行渲染；逻辑层采用 JsCore 线程运行 JS 脚本。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端 Native 做中转，逻辑层发送网络请求也经由 Native 转发

所以我们不要重复 setdata ，以及减少数据的传输量。我们的数据传输实际是一次 Javascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程。去除不必要的事件绑定（ WXML 中的 bind 和 catch ），从而减少通信的数据量和次数。

# 生命周期
![[Pasted image 20220730202329.png]]
```
Component({
  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    },
  },
  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
  attached: function() {
    // 在组件实例进入页面节点树时执行
  },
  detached: function() {
    // 在组件实例被从页面节点树移除时执行
  },
  // ...
})
```
组件所在页面的生命周期：
还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。其中可用的生命周期包括：
![[Pasted image 20220730202459.png]]
# 微信小程序与vue区别
-   生命周期不一样，微信小程序生命周期比较简单
-   数据绑定也不同，微信小程序数据绑定需要使用{{}}，vue直接:就可以 显示与隐藏元素，vue中，使用v-if和v-show
-   控制元素的显示和隐藏，小程序中，使用wx-if和hidden控制元素的显示和隐藏
-   事件处理不同，小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,vue：使用v-on:event绑定事件，或者使用@event绑定事件
-   数据双向绑定也不也不一样在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个data中声明的变量。
# bindtap和catchtap的区别是什么
相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分

不同点：他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻止冒泡的

# 小程序wxml与标准的html的异同？
相同：
-   都是用来描述页面的结构；
-   都由标签、属性等构成；
不同：
-   标签名字不一样，且小程序标签更少，单一标签更多；
-   多了一些wx:if这样的属性以及{{ }}这样的表达式
-   WXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器内预览；
-   组件封装不同，WXML对组件进行了重新封装，
-   小程序运行在JS Core内，没有DOM树和window对象，小程序中无法使用window对象和document对象。

# 三种事件对象的属性列表
基础事件（BaseEvent）
-   type:事件类型
-   timeStamp：事件生成时的时间戳
-   target：触发事件的组件的属性值集合
-   currentTarget：当前组件的一些属性集合
自定义事件（CustomEvent）
-   detail
触摸事件（TouchEvent）
-   touches
-   changedTouches

# 小程序的优劣势？
**优势：**
1.无需下载，通过搜索和扫一扫就可以打开。
2.良好的用户体验：打开速度快。
3.开发成本要比App要低。
4.安卓上可以添加到桌面，与原生App差不多。
5.为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程，不能通过审查的小程序是无法发布到线上的。
**劣势：**
1.限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。
2.样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。
3.推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。
4.依托于微信，无法开发后台管理功能。

# 小程序的按需注入与实时注入
在小程序启动的过程中，除了代码包下载以外，代码注入也是一个主要的耗时环节。注入代码量的大小与内存占用与注入耗时正相关。

利用「**按需注入**」和「**用时注入**」的特性，可以优化代码注入环节的耗时和内存占用。
## 按需注入
通常情况下，在小程序启动时，启动页面依赖的所有代码包（主包、分包、插件包、扩展库等）的所有 JS 代码会全部合并注入，包括其他未访问的页面以及未用到自定义组件，同时所有页面和自定义组件的 JS 代码会被立刻执行。这造成很多没有使用的代码在小程序运行环境中注入执行，影响注入耗时和内存占用。

自基础库版本 2.11.1 起，小程序支持通过配置，有选择地注入必要的代码，以降低小程序的启动时间和运行时内存。

```
{
  "lazyCodeLoading": "requiredComponents"
}
```
-启用按需注入后，小程序仅注入当前访问页面所需的自定义组件和页面代码。未访问的页面、当前页面未声明的自定义组件不会被加载和初始化，对应代码文件将不被执行。**请开发者修改配置后务必确认小程序的表现正常**。
-启用按需注入后，页面 JSON 配置中定义的所有组件和 `app.json` 中 `usingComponents` 配置的全局自定义组件，都会被视为页面的依赖并进行注入和加载。建议开发者**及时移除 JSON 中未使用自定义组件的声明**，并尽量**避免在全局声明使用率低的自定义组件**，否则可能会影响按需注入的效果。
-插件包和扩展库目前暂不支持按需注入。如果需要实现插件按需加载，可以考虑将插件置于一个分包，并通过「[分包异步化](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html)」的形式**异步引入**。

## 用时注入
在开启「按需注入」特性的前提下，「用时注入」可以指定一部分自定义组件不在小程序启动时注入，而是在真正渲染的时候才进行注入。
在已经指定 `lazyCodeLoading` 为 `requiredComponents` 的情况下，为自定义组件配置 [占位组件](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/placeholder.html)，组件就会自动被视为用时注入组件：
1.每个页面内，第一次渲染该组件前，该组件都不会被注入；
2.每个页面内，第一次渲染该组件时，该组件会被渲染为其对应的占位组件，渲染流程结束后开始注入；
3.注入结束后，占位组件被替换回对应组件。

## 分包异步化
在小程序中，不同的分包对应不同的下载单元；因此，除了非独立分包可以依赖主包外，分包之间不能互相使用自定义组件或进行 `require`。「分包异步化」特性将允许通过一些配置和新的接口，使部分跨分包的内容可以等待下载后异步使用，从而一定程度上解决这个限制。 2.11.2以上
### 跨分包 JS 代码引用
一个分包中的代码引用其它分包的代码时，为了不让下载阻塞代码运行，我们需要异步获取引用的结果。如：
```
// subPackageA/index.js
// 使用回调函数风格的调用
require('../subPackageB/utils.js', utils => {
  console.log(utils.whoami) // Wechat MiniProgram
}, ({mod, errMsg}) => {
  console.error(`path: ${mod}, ${errMsg}`)
})
// 或者使用 Promise 风格的调用
require.async('../commonPackage/index.js').then(pkg => {
  pkg.getPackageName() // 'common'
}).catch(({mod, errMsg}) => {
  console.error(`path: ${mod}, ${errMsg}`)
})
```

## 占位组件
在使用如 [分包异步化](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html) 或 [用时注入](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/lazyload.html#%E7%94%A8%E6%97%B6%E6%B3%A8%E5%85%A5) 等特性时，自定义组件所引用的其他自定义组件，在刚开始进行渲染时可能处于不可用的状态。此时，为了使渲染过程不被阻塞，不可用的自定义组件需要一个 **「占位组件」（Component placeholder）**。基础库会用占位组件替代不可用组件进行渲染，在该组件可用后再将占位组件替换回该组件。

一个自定义组件的占位组件可以是另一个自定义组件、或一个内置组件。
### 配置
页面或自定义组件对应的 JSON 配置中的 `componentPlaceholder` 字段用于指定占位组件，如：
```
{
  "usingComponents": {
    "comp-a": "../comp/compA",
    "comp-b": "../comp/compB",
    "comp-c": "../comp/compC"
  },
  "componentPlaceholder": {
    "comp-a": "view",
    "comp-b": "comp-c"
  }
}
```

## 初始渲染缓存
### 工作原理
小程序页面的初始化分为两个部分。
-逻辑层初始化：载入必需的小程序代码、初始化页面 this 对象（也包括它涉及到的所有自定义组件的 this 对象）、将相关数据发送给视图层。
-视图层初始化：载入必需的小程序代码，然后等待逻辑层初始化完毕并接收逻辑层发送的数据，最后渲染页面。
在启动页面时，尤其是小程序冷启动、进入第一个页面时，逻辑层初始化的时间较长。在页面初始化过程中，用户将看到小程序的标准载入画面（冷启动时）或可能看到轻微的白屏现象（页面跳转过程中）。
启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始 data 的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前。它的工作原理如下：
-在小程序页面第一次被打开后，将页面初始数据渲染结果记录下来，写入一个持久化的缓存区域（缓存可长时间保留，但可能因为小程序更新、基础库更新、储存空间回收等原因被清除）；
-在这个页面被第二次打开时，检查缓存中是否还存有这个页面上一次初始数据的渲染结果，如果有，就直接将渲染结果展示出来；
-如果展示了缓存中的渲染结果，这个页面暂时还不能响应用户事件，等到逻辑层初始化完毕后才能响应用户事件。

利用初始渲染缓存，可以：
-快速展示出页面中永远不会变的部分，如导航栏；
-预先展示一个骨架页，提升用户体验；
-展示自定义的加载提示；
-提前展示广告，等等。
### 使用配置
1.静态初始渲染缓存 "initialRenderingCache": "static"
初始渲染缓存记录的是页面 data 应用在页面 WXML 上的结果，不包含任何 setData 的结果
2.在初始渲染缓存中添加动态内容
```
// 配置
"initialRenderingCache": "dynamic"

//初始渲染缓存不会被自动启用，还需要在页面中调用 `this.setInitialRenderingCache(dynamicData)` 才能启用。其中， `dynamicData` 是一组数据，与 `data` 一起参与页面 WXML 渲染。
Page({
  data: {
    loading: true
  },
  onReady: function() {
    this.setInitialRenderingCache({
      loadingHint: '正在加载' // 这一部分数据将被应用于界面上，相当于在初始 data 基础上额外进行一次 setData
    })
  }
})

```



性能 todo
https://developers.weixin.qq.com/miniprogram/dev/framework/audits/performance.html

# cookie、sessionStorage、localStorage、indexDB

- [cookie、sessionStorage、localStorage、indexDB](#cookiesessionstoragelocalstorageindexdb)
	- [一、储存少量数据： cookie，sessionStorage 和 localStorage](#一储存少量数据-cookiesessionstorage-和-localstorage)
		- [1.1 cookie 详解](#11-cookie-详解)
			- [常用属性：](#常用属性)
	- [二、储存大量数据](#二储存大量数据)
		- [indexDB：](#indexdb)
	- [三、应用场景](#三应用场景)
	- [四、 cookie 和 session](#四-cookie-和-session)
	- [总结：](#总结)
	- [多个标签页之间进行通信](#多个标签页之间进行通信)
		- [1.通过 localStorage](#1通过-localstorage)
		- [2.通过 cookie+setInterval](#2通过-cookiesetinterval)

## 一、储存少量数据： cookie，sessionStorage 和 localStorage

**相同点**：cookie，sessionStorage 和 localStorage 都是**存储在浏览器端**的。

**不同点**：

1. **cookie**数据始终在浏览器请求中被携带，在**浏览器端和服务器端来回传递**的；**sessStorage 和 localStorage**同属**于 webStorage**，**仅在本地保存**，不会传递到服务器端
2. 存活时间：**cookie 在设置的存活时间之前一直有效**，**sessionStorage**在浏览器**窗口关闭之前**一直有效，**localStorage 始终有效**
3. 存储大小：**cookie 只有 4KB**，sessionStorage 和 localStorage 存储空间大一些(**大概 5Mb 左右**）
4. 作用域：**sessionStorage 不在不同的浏览器窗口中共享，即使同一个页面**，
   而 cookie 和 localStorage 在**同源窗口**（协议、域名、端口相同）中均**共享**
5. 储存类型：webStorage 只能存字符串，无法直接存对象。cookie 存的是文本文件。

### 1.1 cookie 详解

#### 常用属性：

- Expires => 过期时间 Expires = Web, 21 0ct 2015 07: 28 :00 GMT

- Max-age => 设置过期需要经过的秒数 （比 Expires 的优先级高） Max-age = 60000

- Domian => 设定送达的主机名

- Path => 指定一个 URL。必须出现在要请求的路径中才可以发送 Cookie 首部

- Secure => cookie 只有通过 HTTPS 加密过才能发送给服务端

  - 修改 cookie 时，domain 和 path 都相同才可以进行，有不同则创建一个新的 cookie
  - cookie 过期就会被浏览器删除
  - 有助于避免 XSS 攻击

- HTTPOnly => 只允许通过请求访问 cookie，避免 document.cookie 方式攻击，有助于避免 CSRF 攻击

- 二级域名能读取设置了 domain 为顶级域名或者自身的 cookie，不能读取其他二级域名 domain 的 cookie。例如：要想 cookie 在多个二级域名中共享，需要设置 domain 为顶级域名，这样就可以在所有二级域名里面或者到这个 cookie 的值了。

- 顶级域名只能获取到 domain 设置为顶级域名的 cookie，domain 设置为其他子级域名的无法获取。

## 二、储存大量数据

### indexDB：

特性：

1. 储存量理论没有上限
2. 操作是异步的。 loaclStorage 是同步的。操作性能高
3. 支持储存 JS 的对象
4. 是正经的数据库，数据库能干的他都可以

缺点：

1. 操作繁琐
2. 本身有门槛

## 三、应用场景

1. cookie：标记用户与跟踪用户行为
2. localStorage：长期保存在本地的数据（令牌）
3. sessionStorage：敏感账号一次性登陆
4. indexDB：储存大量数据、在线文档（富文本编辑器）、保存编辑历史。

## 四、 cookie 和 session

cookie 数据存储在客户端，session 数据存储在服务器。

相比 session，**cookie 不是很安全**，别人可以分析存储在本地的 cookie 并进行 cookie 诈骗；

而**session，当访问增多时，会比较占用服务器性能**。

我们已经知道 session 时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session 就会面对负载均衡问题。

负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享 session。这个问题也可以将 session 存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。

## 总结：

1. **Cookie**受到浏览器**同源策略的限制**，A 页面的 Cookie 无法被 B 页面的 Cookie 访问和操作。

2. Cookie 最大存储容量一般为 4KB，**由服务器生成**，在 HTTP 报文首部设置 **Set-Cookie 可以指定生成 Cookie 的内容和生命周期，保存在硬盘中**；如果**没有设置过期时间就是会话 cookie**，**保存在内存中**，**关闭浏览器窗口就会失效**。

> 即 cookie 有两种。一种放在硬盘，有生命周期。另一种放在内存（会话 cookie），关闭浏览器就失效。

3. Cookie 存储在浏览器端，由于**每次发送 HTTP 请求默认会把 Cookie 附到 HTTP 首部上去**，所以 Cookie**主要用来身份认证，而不用来存储其他信息**，防止 HTTP 报文过大。

4. Session 存储在服务器，主要**与 Cookie 配合使用完成身份认证和状态保持的功能**。

   > cookie 只是实现 session 的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用 cookie 后还有其他方法存储，比如放在 url 中

   > 现在大多都是 Session + Cookie，但是只用 session 不用 cookie，或是只用 cookie，不用 session 在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用

   > 用 session 只需要在客户端保存一个 id，实际上大量数据都是保存在服务端。如果全部用 cookie，数据量大的时候客户端是没有那么多空间的。

   > 如果只用 cookie 不用 session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大

> - 对 Cookie 和 Session 实现的身份认证和状态保持功能做一个举例。
>
> 假设现在有一个学生信息管理系统，此时数据库已经有学生的相关信息（账号、密码、个人信息等等）。
>
>     然后当学生登录这个系统，通过POST请求把用户的账户密码发送到后台服务器。当后台服务器接收到这些参数的时候，会跟数据库保存的记录进行匹配。
>
> 一旦匹配成功，也就是用户的账号密码都正确的情况下，这个时候后台服务器会生成 Session（一个为客户端开辟存储空间，用来保存会话的状态信息），并生成一个相应的 SessionID，可以是用户名或者其他能够唯一标识用户的字段。然后后台服务器会返回响应告知客户端登录成功，可以进行后续的操作。此时，后台服务器会在 HTTP 响应报文中添加一个字段
> Set-Cookie，它的值是当前 Session 的 SessionID，（这个 SessionID 是指向我们当前的那个 Session 的，在 Node 的 Express 中 express-session 会封装好这个过程）当然还会设置 Cookie 的其他属性，比如说过期时间
> Expires 等等。
>
> 当浏览器接收到这个 HTTP 响应报文的时候，就会在本地设置一个 Cookie，它的过期时间由响应报文中 Set-Cookie 中的
> Expires 字段的值决定，如果为空，则关闭浏览器（即会话结束时）后失效。
>
> 之后，每次向后台服务器发送请求的时候，浏览器默认会把这个 Cookie 加在 HTTP 请求报文的 Cookie 中。这样，每次后台服务器接收到请求的时候，会根据 Cookie 中的 SessionID 去找到我们的 Session。
>
> 假如这个 SessionID 映射得到 Session，那么这个时候说明浏览器是已经登录过了。于是，就可以进行后续的一些相关的操作。
>
> 另外，值得一提的是，Session 机制决定了当前客户只会获取到自己的 Session，而不会获取到别人的 Session。各客户的 Session 也彼此独立，互不可见。也就是说，当多个客户端执行程序时，服务器会保存多个客户端的 Session。获取 Session 的时候也不需要声明获取谁的 Session。
> 选自：[面经复习-浏览器缓存和 304](https://blog.csdn.net/qq_30012951/article/details/108738241)

## 多个标签页之间进行通信

### 1.通过 localStorage

**在一个标签页中设置 localStorage，在另一个标签页中监听 Storage 事件。**

关于触发 Storage 事件：

1. storage 事件，针对都是**非当前页面对 localStorage 进行修改时才会触发**，当前页面修改 localStorage 不会触发监听函数。
2. 在**对原有的数据的值进行修改时才会触发**，比如原本已经有一个 key 会 a 值为 b 的 localStorage，你再执行 localStorage.setItem('a', 'b')代码，是不会触发 storag 事件的。

标签页 1

```html
<input id="name" />
<input type="button" id="btn" value="提交" />
<script type="text/javascript">
	$(function () {
		$("#btn").click(function () {
			var name = $("#name").val();
			localStorage.setItem("name", name);
		});
	});
</script>
```

标签页 2

```html
<script type="text/javascript">
	$(function () {
		window.addEventListener("storage", function (event) {
			console.log(event.key + "=" + event.newValue);
		});
	});
</script>
```

### 2.通过 cookie+setInterval

**在一个标签页中将要传递的信息存储到 cookie 中，在另一个标签页中定时读取 cookie**

标签页 1

```html
<input id="name" />
<input type="button" id="btn" value="提交" />
<script type="text/javascript">
	$(function () {
		$("#btn").click(function () {
			var name = $("#name").val();
			document.cookie = "name=" + name;
		});
	});
</script>
```

标签页 2

```html
<script type="text/javascript">
	$(function () {
		function getCookie(key) {
			return JSON.parse(
				'{"' +
					document.cookie.replace(/;\s+/gim, '","').replace(/=/gim, '":"') +
					'"}'
			)[key];
		}
		setInterval(function () {
			console.log("name=" + getCookie("name"));
		}, 10000);
	});
</script>
```

# 页面生命周期：DOMContentLoaded，load，beforeunload，unload
[页面生命周期]https://zh.javascript.info/onload-ondomcontentloaded

**HTML 页面的生命周期包含三个重要事件**：
-   `DOMContentLoaded` —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 `<img>` 和样式表之类的外部资源可能尚未加载完成。
-   `load` —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。
-   `beforeunload/unload` —— 当用户正在离开页面时。

每个事件都是有用的：
-   `DOMContentLoaded` 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。
-   `load` 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。
-   `beforeunload` 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。
-   `unload` 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。

## [DOMContentLoaded](https://zh.javascript.info/onload-ondomcontentloaded#domcontentloaded)
`DOMContentLoaded` 事件发生在 `document` 对象上。 `addEventListener` 来捕获：
```
document.addEventListener("DOMContentLoaded", ready); 
// 不是 "document.onDOMContentLoaded = ..."
```

乍一看，`DOMContentLoaded` 事件非常简单。DOM 树准备就绪 —— 这是它的触发条件。它并没有什么特别之处。可以查看所有元素，包括它下面的 `<img>` 元素。但是，它不会等待图片加载。因此，`alert` 显示其大小为零。
如果我们在文档加载完成之后设置 `DOMContentLoaded` 事件处理程序, 它永远不会运行。


### [DOMContentLoaded 和脚本](https://zh.javascript.info/onload-ondomcontentloaded#domcontentloaded-he-jiao-ben)
因为脚本可能想要修改 DOM，甚至对其执行 `document.write` 操作，所以 `DOMContentLoaded` 必须等待脚本执行结束。
普通外联，内嵌脚本都会在`DOMContentLoaded`前解析执行。
```
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"></script> <script> alert("Library loaded, inline script executed"); </script>
```
不会阻塞 `DOMContentLoaded` 的脚本
此规则有两个例外：
1.  具有 `async` 特性（attribute）的脚本不会阻塞 `DOMContentLoaded`，[稍后](https://zh.javascript.info/script-async-defer) 我们会讲到。
2.  使用 `document.createElement('script')` 动态生成并添加到网页的脚本也不会阻塞 `DOMContentLoaded`。

### [DOMContentLoaded 和样式](https://zh.javascript.info/onload-ondomcontentloaded#domcontentloaded-he-yang-shi)

外部样式表不会影响 DOM，因此 `DOMContentLoaded` 不会等待它们。
```
<link type="text/css" rel="stylesheet" href="style.css">
```
但这里有一个陷阱。如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成：
原因是，脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。
当 `DOMContentLoaded` 等待脚本时，它现在也在等待脚本前面的样式。

## [window.onload](https://zh.javascript.info/onload-ondomcontentloaded#window-onload)

当整个页面，包括样式、图片和其他资源被加载完成时（`并行`请求图片或者视频等），会触发 `window` 对象上的 `load` 事件。可以通过 `onload` 属性获取此事件。也可以通过addEventListener监听load事件。
```
<script>

  window.onload = function() { // 也可以用 window.addEventListener('load', (event) => 
  {alert('Page loaded');
   // 此时图片已经加载完成
   alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);
  };

</script>

<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">
```

## [window.onbeforeunload](https://zh.javascript.info/onload-ondomcontentloaded#window.onbeforeunload)

如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，`beforeunload` 处理程序将要求进行更多确认。
如果我们要取消事件，浏览器会询问用户是否确定。
```
window.onbeforeunload = function() { return false; };
```
或
```
window.addEventListener("beforeunload", (event) => { // 起作用，与在 window.onbeforeunload 中 return 值的效果是一样的 event.returnValue = "有未保存的值。确认要离开吗？"; });
```
由于历史原因，返回非空字符串也被视为取消事件。在以前，浏览器曾经将其显示为消息，但是根据 [现代规范](https://html.spec.whatwg.org/#unloading-documents) 所述，它们不应该这样。
`event.preventDefault()` 在 `beforeunload` 处理程序中不起作用

## [window.onunload](https://zh.javascript.info/onload-ondomcontentloaded#windowonunload)

当访问者离开页面时，`window` 对象上的 `unload` 事件就会被触发。我们可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。
(sendBeacon: 有一个值得注意的特殊情况是发送分析数据。假设我们收集有关页面使用情况的数据：鼠标点击，滚动，被查看的页面区域等。自然地，当用户要离开的时候，我们希望通过 `unload` 事件将数据保存到我们的服务器上。个特殊的 `navigator.sendBeacon(url, data)` 方法可以满足这种需求.它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 `sendBeacon`。
```
let analyticsData = { /* 带有收集的数据的对象 */ }; window.addEventListener("unload", function() { navigator.sendBeacon("/analytics", JSON.stringify(analyticsData)); });
```
)

## [readyState](https://zh.javascript.info/onload-ondomcontentloaded#readystate)
在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 DOM 加载完成时执行，无论现在还是以后。
`document.readyState` 属性可以为我们提供当前加载状态的信息。

它有 3 个可能值：
-   `loading` —— 文档正在被加载。
-   `interactive` —— 文档被全部读取。
-   `complete` —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成。
所以，我们可以检查 `document.readyState` 并设置一个处理程序，或在代码准备就绪时立即执行它。

用法：
```
function work() { /*...*/ }

if (document.readyState == 'loading') {
	// 仍在加载，等待事件 
	document.addEventListener('DOMContentLoaded', work); 
} else { 
	// DOM 已就绪！ 
	work(); 
}
```
还有一个 `readystatechange` 事件，会在状态发生改变时触发，它很早就存在了。现在则很少被使用。
```
document.addEventListener('readystatechange', () => console.log(document.readyState));
```

## [总结](https://zh.javascript.info/onload-ondomcontentloaded#zong-jie)

页面生命周期事件：

-   当 DOM 准备就绪时，`document` 上的 `DOMContentLoaded` 事件就会被触发。在这个阶段，我们可以将 JavaScript 应用于元素。
    -   诸如 `<script>...</script>` 或 `<script src="..."></script>` 之类的脚本会阻塞 `DOMContentLoaded`，浏览器将等待它们执行结束。
    -   图片和其他资源仍然可以继续被加载。
-   当页面和所有资源都加载完成时，`window` 上的 `load` 事件就会被触发。我们很少使用它，因为通常无需等待那么长时间。
-   当用户想要离开页面时，`window` 上的 `beforeunload` 事件就会被触发。如果我们取消这个事件，浏览器就会询问我们是否真的要离开（例如，我们有未保存的更改）。
-   当用户最终离开时，`window` 上的 `unload` 事件就会被触发。在处理程序中，我们只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。我们可以使用 `navigator.sendBeacon` 来发送网络请求。
-   `document.readyState` 是文档的当前状态，可以在 `readystatechange` 事件中跟踪状态更改：
    -   `loading` —— 文档正在被加载。
    -   `interactive` —— 文档已被解析完成，与 `DOMContentLoaded` 几乎同时发生，但是在 `DOMContentLoaded` 之前发生。
    -   `complete` —— 文档和资源均已加载完成，与 `window.onload` 几乎同时发生，但是在 `window.onload` 之前发生。

# 脚本：async，defer
加载 HTML 时遇到 `<script>...</script>`,外部脚本 `<script src="..."></script>`必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。
导致两个重要的问题：
1.  脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。
2.  如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容
有一些解决办法。例如，我们可以把脚本放在页面底部。此时，它可以访问到它上面的元素，并且不会阻塞页面显示内容。但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML 文档之后才会注意到该脚本（并且可以开始下载它）。对于长的 HTML 文档来说，这样可能会造成明显的延迟。

## [defer](https://zh.javascript.info/script-async-defer#defer)

`defer` 特性告诉浏览器不要等待脚本。相反，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行。
换句话说：
-   具有 `defer` 特性的脚本不会阻塞页面。
-   具有 `defer` 特性的脚本总是要等到 DOM 解析完毕，但在 `DOMContentLoaded` 事件之前执行。

`defer` 特性仅适用于外部脚本
如果 `<script>` 脚本没有 `src`，则会忽略 `defer` 特性。

## [async](https://zh.javascript.info/script-async-defer#async)
`async` 特性意味着脚本是完全独立的：
-   浏览器不会因 `async` 脚本而阻塞（与 `defer` 类似）。
-   其他脚本不会等待 `async` 脚本加载完成，同样，`async` 脚本也不会等待其他脚本。
-   `DOMContentLoaded` 和异步脚本不会彼此等待：
    -   `DOMContentLoaded` 可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）
    -   `DOMContentLoaded` 也可能发生在异步脚本之后（如果异步脚本很短，或者是从 HTTP 缓存中加载的）
换句话说，`async` 脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。`async` 脚本就是一个会在加载完成时执行的完全独立的脚本。

`async` 特性仅适用于外部脚本
就像 `defer` 一样，如果 `<script>` 标签没有 `src` 特性（attribute），那么 `async` 特性会被忽略。
![[Pasted image 20220619112807.png]]

## [动态脚本](https://zh.javascript.info/script-async-defer#dong-tai-jiao-ben)

此外，还有一种向页面添加脚本的重要的方式。
我们可以使用 JavaScript 动态地创建一个脚本，并将其附加（append）到文档（document）中：
```
let script = document.createElement('script');
script.src = "/article/script-async-defer/long.js"; 
document.body.append(script); // (*)
```
本被附加到文档 `(*)` 时，脚本就会立即开始加载,**默认情况下，动态脚本的行为是“异步”的。**
-   它们不会等待任何东西，也没有什么东西会等它们。
-   先加载完成的脚本先执行（“加载优先”顺序）。
显式地设置了 `script.async=false`，则可以改变这个规则,会按顺序执行

## [总结](https://zh.javascript.info/script-async-defer#zong-jie)

`async` 和 `defer` 有一个共同点：加载这样的脚本都不会阻塞页面的渲染。因此，用户可以立即阅读并了解页面内容。
![[1653634343(1).png]]

在实际开发中，`defer` 用于需要整个 DOM 的脚本，和/或脚本的相对执行顺序很重要的时候。

`async` 用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要。

没有脚本的页面应该也是可用的

请注意：如果你使用的是 `defer` 或 `async`，那么用户将在脚本加载完成 **之前** 先看到页面。

在这种情况下，某些图形组件可能尚未初始化完成。

因此，请记得添加一个“正在加载”的提示，并禁用尚不可用的按钮。以让用户可以清楚地看到，他现在可以在页面上做什么，以及还有什么是正在准备中的。

# 资源加载：onload，onerror
跟踪外部资源的加载 —— 脚本，iframe，图片等两个事件：
-   `onload` —— 成功加载，
-   `onerror` —— 出现 error。

`load` 和 `error` 事件也适用于其他资源，基本上（basically）适用于具有外部 `src` 的任何资源。
## 加载事项
https://tsejx.github.io/javascript-guidebook/browser-object-model/browser-working-principle/script-loading-asynchronously/ 
-   `<link>`：加载外部 CSS 样式文件 。异步加载，继续解析 HTML。
-   `<script src='url'>`：加载 JavaScript 脚本文件，同步加载并阻塞解析 HTML，加载完马上执行。
-   `<script src='url' async>`：加载 JavaScript 脚本文件。异步加载，继续解析 HTML，加载完马上执行。
-   `<script src='url' defer>`：加载 JavaScript 脚本文件。异步加载，继续解析 HTML，加载完延迟执行。
-   `<img src='url' />`：加载图片，异步加载，继续解析 HTML；但是需要等待 CSS 解析完才解码，所以 CSS 阻塞图片呈现。

DOMContentLoaded 标识着程序从同步脚本执行转化为事件驱动阶段。

-   CSSOM 树和 DOM 树是互不关联的两个过程
-   CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染
-   JavaScript 阻塞 DOM 解析，但浏览器会"偷看"DOM，提前下载资源
-   平时我们把 `<link>` 标签放部头而 `<script>` 放 `<body>` 尾部，是因为 JavaScript 阻塞阻塞 DOM 树的构建
-   但是 JavaScript 需要查询 CSS 信息，所以 JavaScript 还要等待 CSSOM 树构建完才可以执行
-   这就造成 CSS 阻塞了 JavaScript，JavaScript 阻塞了 DOM 树构建

-   浏览器遇到 `<script>` 且没有 `defer` 或 `async` 属性的标签时，会触发页面渲染，因而如果前面 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。

## [跨源策略](https://zh.javascript.info/onload-onerror#kua-yuan-ce-lve)
这里有一条规则：来自一个网站的脚本无法访问其他网站的内容。例如，位于 `https://facebook.com` 的脚本无法读取位于 `https://gmail.com` 的用户邮箱。
或者，更确切地说，一个源（域/端口/协议三者）无法获取另一个源（origin）的内容。因此，即使我们有一个子域，或者仅仅是另一个端口，这都是不同的源，彼此无法相互访问。
这个规则还影响其他域的资源。
如果我们使用的是来自其他域的脚本，并且该脚本中存在 error，那么我们无法获取 error 的详细信息。
**要允许跨源访问，`<script>` 标签需要具有 `crossorigin` 特性（attribute），并且远程服务器必须提供特殊的 header。**
这里有三个级别的跨源访问：
1.  **无 `crossorigin` 特性** —— 禁止访问。
2.  **`crossorigin="anonymous"`** —— 如果服务器的响应带有包含 `*` 或我们的源（origin）的 header `Access-Control-Allow-Origin`，则允许访问。浏览器不会将授权信息和 cookie 发送到远程服务器。
3.  **`crossorigin="use-credentials"`** —— 如果服务器发送回带有我们的源的 header `Access-Control-Allow-Origin` 和 `Access-Control-Allow-Credentials: true`，则允许访问。浏览器会将授权信息和 cookie 发送到远程服务器。

预加载图片
```
    function preloadImages(sources, callback) {

      /* your code */

    }

    // ---------- The test ----------

    let sources = [

      "https://en.js.cx/images-load/1.jpg",

      "https://en.js.cx/images-load/2.jpg",

      "https://en.js.cx/images-load/3.jpg"

    ];

    // add random characters to prevent browser caching

    for (let i = 0; i < sources.length; i++) {

      sources[i] += '?' + Math.random();

    }
    // for each image,

    // let's create another img with the same src and check that we have its width immediately

    function testLoaded() {

      let widthSum = 0;

      for (let i = 0; i < sources.length; i++) {

        let img = document.createElement('img');

        img.src = sources[i];

        widthSum += img.width;

      }

      alert(widthSum);

    }

    // every image is 100x100, the total width should be 300

    preloadImages(sources, testLoaded);
```
## 谁会阻塞谁
https://juejin.cn/post/6844904097422770183
### 1.外链CSS加载是否会阻塞
1.css加载不会阻塞DOM树的解析，并行
2.css加载会阻塞渲染，阻塞render tree的构建
3.css加载会阻塞后面js语句的执行（陷阱）**也就是说在JavaScript之前的CSS样式，准确的说，是被JavaScript依赖执行的CSS（内联CSS、以及JavaScript标签之前的外联CSS）,有可能会因为JavaScript的影响，间接阻塞了DOM的构建**

相关优化：
我们可以设置延迟执行和异步下载减少JavaScript对DOM构建的影响。
如果想首屏渲染更快，那么不应该在首屏就加载JS文件，建议将script标签放到body标签底部。
* 从渲染过程来分析
1.DOM解析和CSS解析是两个并行的进程，外部样式表不会影响 DOM，因此 `DOMContentLoaded` 不会等待它们，所以这也解释了为什么CSS加载不会阻塞DOM的解析。
2.然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。
3.如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成，由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行，脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。当 `DOMContentLoaded` 等待脚本时，它现在也在等待脚本前面的样式。
* 尽可能的提高css加载速度，比如可以使用以下几种方法:
1.使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
2.对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)
3.合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
4.减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)
#### 陷阱
### 2.js是否会阻塞
JavaScript会阻塞HTML的解析过程
当HTML解析器碰到script标签的时候，它会停止HTML文档的解析从而转向JavaScript代码的加载，解析以及执行。为什么要这样做呢？因为script标签中的JavaScript可能会使用诸如`document.write()`这样的代码改变文档流（document）的形状，从而使整个DOM树的结构发生根本性的改变
defer sync
![[Pasted image 20220821180824.png]]


3.图片资源加载会阻塞什么
4.阻塞DOM、不会阻塞DOM构建的分别有
阻塞DOM构建的有：
1.JavaScript标签之前的CSS
2.外联普通JavaScript
3.外联defer-JavaScript的执行过程
4.内联JavaScript
不会阻塞DOM构建的有：
1.JavaScript标签之后的CSS
2.外联async-JavaScript
3.外联defer-JavaScript的加载过程
4.image
5.iframe

### 3.渲染页面时常见的不良现象
1. FOUS(无样式内容闪烁)：
由于浏览器渲染机制（火狐），在CSS加载前，先呈现了HTML，因此会展示出无样式的内容，然后样式突然呈现的现象。
2. 白屏
有些浏览器的渲染机制（比如chrome）要先构建DOM树和CSSOM树，构建完成再进行渲染。如果CSS部分放在HTML尾部，由于CSS未加载完成，浏览器迟迟未渲染，就会导致白屏。  
也有可能是JS文件放在了头部，阻塞了后续DOM的构建和组件的下载，导致了白屏的产生。

### 4.script外链放在body底部，改变了什么，优化的是什么？
https://segmentfault.com/a/1190000004292479
https://cloud.tencent.com/developer/article/1157051

不能改变DomContentLoaded时间，即不能改变DOM完全加载完的时间
**在生成Dom树的过程中只要某些条件具备了，“没有图片的首屏”就能显示出来。**

**DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。**

关注浏览器渲染过程，浏览器第一次painting时机，可能早于js加载完成，在load后会再次painting(中间可能还会painting)；js是否放在body底部不影响（如果这里里的首屏指的是页面从白板变成网页画面——也就是第一次Painting），但有可能（下载解析比较慢时）截断首屏的内容，使其只显示上面一部分，放在底部可以使得在第一次painting时尽可能多得展示首屏内容。

1.首屏时间和DomContentLoad事件没有必然的先后关系
2.所有CSS尽早加载是减少首屏时间的最关键
-   js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。
-   script标签放在body底部，做与不做async或者defer处理，都不会影响首屏时间，但影响DomContentLoad和load的时间，进而影响依赖他们的代码的执行的开始时间。

**第一次渲染：FP的执行时间**
FP发生在body中第一个script脚本之前的CSS解析和JS执行完成之后。换句话说就是第一脚本之前的`DOM`和`CSSOM`准备就绪之后，便会着手渲染第一脚本前的内容。
如果第一脚本前的JS和CSS加载完了，`body`中的脚本还未下载完成，那么浏览器就会利用构建好的局部`CSSOM`和`DOM`提前渲染第一脚本前的内容（触发`FP`）；如果第一脚本前的JS和CSS都还没下载完成，`body`中的脚本就已经下载完了，那么浏览器就会在所有JS脚本都执行完之后才触发FP。
优化建议：
-CSS放在head中，JS放在`</body>`前（如果在head必须放JS，也尽量减少他的大小，把大JS文件放`</body>`前）。
-减小head中CSS和JS大小（`gzip`[了解一下？](https://segmentfault.com/a/1190000012800222))，
-优化head中的JS和CSS外链的网络情况，减少`Stalled`、`TTFB`和`Content Download`的时间。
-在第一脚本前使用骨架图，可以减少用户的白屏感知时间（对于使用JS插入模板来渲染的框架，建议将骨架图的路由生成逻辑单独提出来）

### 5.浏览器的渲染过程
1.**创建/更新DOM，并行请求CSS/IMAGE/JS等资源**（chrome预扫描）
2.**创建/更新CSSOM**：在CSS下载完成后，开始构建CSSOM
3.**创建/更新RenderTree**：所有CSS下载完，CSSOM构建完，和DOM一起生成RenderTree
4.**Layout**：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。
5.**Painting**：Layout后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的CSS属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry）。就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上。
  包括：
	（1）构建图层：对渲染树进行分层操作，并生成分层树；（Layers，有层叠上下文属性的元素，需要剪裁的元素，3D之类的）
	（2）为每个图层生成由绘制指令组成的绘制列表，并提交到合成线程；
	（3）合成线程将图层分成不同的图块，并通过光栅化按绘制列表生成位图，存在内存中；
	（4）合成线程给浏览器进程发送绘制图块指令；
	（5）浏览器进程会生成页面，内存中存储的位图显示在屏幕上。

DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。
Layout 和 Painting 也会被**重复**执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。